{
    "original": "https://prover.certora.com/output/686351/6ee02d27b94d4e34bc321eaea43696a0?anonymousKey=5556369ae485cc82cb400bec0c4c1071bd351529",
    "mutants": [
        {
            "gambit_mutant": {
                "filename": "gambit_out/mutants/1/ERC20.sol",
                "original_filename": "ERC20.sol",
                "directory": "gambit_out/mutants/1",
                "id": "1",
                "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        /// RequireMutation(`balances[src] >= wad` |==> `false`) of: `require(balances[src] >= wad, \"insufficient-balance\");`\n+        require(false, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
                "description": "RequireMutation",
                "name": "1_ERC20"
            },
            "link": "https://prover.certora.com/jobStatus/686351/acde92193f1a4f0bae12c5d2730a357f?anonymousKey=486ab338857bdd1f82fdc4337beec8088f2b37a6",
            "success": true,
            "run_directory": ".certora_internal/24_03_17_01_24_15_577/.certora_sources",
            "rule_report_link": "https://prover.certora.com/output/686351/acde92193f1a4f0bae12c5d2730a357f?anonymousKey=486ab338857bdd1f82fdc4337beec8088f2b37a6"
        },
        {
            "gambit_mutant": {
                "filename": "gambit_out/mutants/2/ERC20.sol",
                "original_filename": "ERC20.sol",
                "directory": "gambit_out/mutants/2",
                "id": "2",
                "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        /// AssignmentMutation(`balances[src].sub(wad)` |==> `1`) of: `balances[src] = balances[src].sub(wad);`\n+        balances[src] = 1;\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
                "description": "AssignmentMutation",
                "name": "2_ERC20"
            },
            "link": "https://prover.certora.com/jobStatus/686351/28efa3dfb9ec48c59bcba0e569f2925e?anonymousKey=22238a28d449707991c70eeeb0dabd08ef27809d",
            "success": true,
            "run_directory": ".certora_internal/24_03_17_01_24_15_061/.certora_sources",
            "rule_report_link": "https://prover.certora.com/output/686351/28efa3dfb9ec48c59bcba0e569f2925e?anonymousKey=22238a28d449707991c70eeeb0dabd08ef27809d"
        },
        {
            "gambit_mutant": {
                "filename": "gambit_out/mutants/3/ERC20.sol",
                "original_filename": "ERC20.sol",
                "directory": "gambit_out/mutants/3",
                "id": "3",
                "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        /// AssignmentMutation(`wad` |==> `0`) of: `allowance[src][usr] = wad;`\n+        allowance[src][usr] = 0;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
                "description": "AssignmentMutation",
                "name": "3_ERC20"
            },
            "link": "https://prover.certora.com/jobStatus/686351/f82eec67d8c94e7c97f4584e8eaf6257?anonymousKey=7f2e530212af73b4efee61f9b7f92ecc5a3e727d",
            "success": true,
            "run_directory": ".certora_internal/24_03_17_01_24_16_553/.certora_sources",
            "rule_report_link": "https://prover.certora.com/output/686351/f82eec67d8c94e7c97f4584e8eaf6257?anonymousKey=7f2e530212af73b4efee61f9b7f92ecc5a3e727d"
        },
        {
            "gambit_mutant": {
                "filename": "gambit_out/mutants/4/ERC20.sol",
                "original_filename": "ERC20.sol",
                "directory": "gambit_out/mutants/4",
                "id": "4",
                "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        /// AssignmentMutation(`balances[usr].add(wad)` |==> `0`) of: `balances[usr] = balances[usr].add(wad);`\n+        balances[usr] = 0;\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
                "description": "AssignmentMutation",
                "name": "4_ERC20"
            },
            "link": "https://prover.certora.com/jobStatus/686351/78bb7faef45e4c1e9e6cad29d378a1f9?anonymousKey=dd2da0541f0ad8258ac7dd12b254e5f9908916e9",
            "success": true,
            "run_directory": ".certora_internal/24_03_17_01_24_15_950/.certora_sources",
            "rule_report_link": "https://prover.certora.com/output/686351/78bb7faef45e4c1e9e6cad29d378a1f9?anonymousKey=dd2da0541f0ad8258ac7dd12b254e5f9908916e9"
        },
        {
            "gambit_mutant": {
                "filename": "gambit_out/mutants/5/ERC20.sol",
                "original_filename": "ERC20.sol",
                "directory": "gambit_out/mutants/5",
                "id": "5",
                "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        /// AssignmentMutation(`balances[usr].add(wad)` |==> `1`) of: `balances[usr] = balances[usr].add(wad);`\n+        balances[usr] = 1;\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
                "description": "AssignmentMutation",
                "name": "5_ERC20"
            },
            "link": "https://prover.certora.com/jobStatus/686351/56afc98daf4e4f1894007f299a3ed0d3?anonymousKey=0c8415bddda74eaba0cb8b91e6c97522d0bc2ed2",
            "success": true,
            "run_directory": ".certora_internal/24_03_17_01_24_15_785/.certora_sources",
            "rule_report_link": "https://prover.certora.com/output/686351/56afc98daf4e4f1894007f299a3ed0d3?anonymousKey=0c8415bddda74eaba0cb8b91e6c97522d0bc2ed2"
        },
        {
            "gambit_mutant": {
                "filename": "gambit_out/mutants/6/ERC20.sol",
                "original_filename": "ERC20.sol",
                "directory": "gambit_out/mutants/6",
                "id": "6",
                "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        /// AssignmentMutation(`balances[usr].sub(wad)` |==> `0`) of: `balances[usr] = balances[usr].sub(wad);`\n+        balances[usr] = 0;\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
                "description": "AssignmentMutation",
                "name": "6_ERC20"
            },
            "link": "https://prover.certora.com/jobStatus/686351/b6827bf612f645ddbfb577e99a7b0ccb?anonymousKey=b71bb883bc9a9be326f66d6f1ace35e239b052de",
            "success": true,
            "run_directory": ".certora_internal/24_03_17_01_24_15_526/.certora_sources",
            "rule_report_link": "https://prover.certora.com/output/686351/b6827bf612f645ddbfb577e99a7b0ccb?anonymousKey=b71bb883bc9a9be326f66d6f1ace35e239b052de"
        },
        {
            "gambit_mutant": {
                "filename": "gambit_out/mutants/7/ERC20.sol",
                "original_filename": "ERC20.sol",
                "directory": "gambit_out/mutants/7",
                "id": "7",
                "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        /// AssignmentMutation(`balances[usr].sub(wad)` |==> `1`) of: `balances[usr] = balances[usr].sub(wad);`\n+        balances[usr] = 1;\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
                "description": "AssignmentMutation",
                "name": "7_ERC20"
            },
            "link": "https://prover.certora.com/jobStatus/686351/710507a5772a4ce590750e68f64ecc41?anonymousKey=4ece8b4b1efb797a8a5f19b6423944dd2335c93d",
            "success": true,
            "run_directory": ".certora_internal/24_03_17_01_24_15_323/.certora_sources",
            "rule_report_link": "https://prover.certora.com/output/686351/710507a5772a4ce590750e68f64ecc41?anonymousKey=4ece8b4b1efb797a8a5f19b6423944dd2335c93d"
        },
        {
            "gambit_mutant": {
                "filename": "gambit_out/mutants/8/ERC20.sol",
                "original_filename": "ERC20.sol",
                "directory": "gambit_out/mutants/8",
                "id": "8",
                "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        /// AssignmentMutation(`_totalSupply.sub(wad)` |==> `1`) of: `_totalSupply = _totalSupply.sub(wad);`\n+        _totalSupply = 1;\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
                "description": "AssignmentMutation",
                "name": "8_ERC20"
            },
            "link": "https://prover.certora.com/jobStatus/686351/5e2bd850bff74fe39c4638cba6c67e39?anonymousKey=d065a6e6ea781a7faaaff29e7b15f49bd2017e56",
            "success": true,
            "run_directory": ".certora_internal/24_03_17_01_24_16_429/.certora_sources",
            "rule_report_link": "https://prover.certora.com/output/686351/5e2bd850bff74fe39c4638cba6c67e39?anonymousKey=d065a6e6ea781a7faaaff29e7b15f49bd2017e56"
        },
        {
            "gambit_mutant": {
                "filename": "gambit_out/mutants/9/ERC20.sol",
                "original_filename": "ERC20.sol",
                "directory": "gambit_out/mutants/9",
                "id": "9",
                "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        /// AssignmentMutation(`balances[src].sub(wad)` |==> `1`) of: `balances[src] = balances[src].sub(wad);`\n+        balances[src] = 1;\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
                "description": "AssignmentMutation",
                "name": "9_ERC20"
            },
            "link": "https://prover.certora.com/jobStatus/686351/b6ec04834b5943dd9da324da9da348de?anonymousKey=19c25ee3016004da2aa1f978ea263595cd8c0d41",
            "success": true,
            "run_directory": ".certora_internal/24_03_17_01_24_16_884/.certora_sources",
            "rule_report_link": "https://prover.certora.com/output/686351/b6ec04834b5943dd9da324da9da348de?anonymousKey=19c25ee3016004da2aa1f978ea263595cd8c0d41"
        },
        {
            "gambit_mutant": {
                "filename": "gambit_out/mutants/10/ERC20.sol",
                "original_filename": "ERC20.sol",
                "directory": "gambit_out/mutants/10",
                "id": "10",
                "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        /// AssignmentMutation(`balances[dst].add(wad)` |==> `0`) of: `balances[dst] = balances[dst].add(wad);`\n+        balances[dst] = 0;\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
                "description": "AssignmentMutation",
                "name": "10_ERC20"
            },
            "link": "https://prover.certora.com/jobStatus/686351/32f4d94f79ff4d8889ea4896068860f2?anonymousKey=a4098599ac655b9cd7e6d85af1bd442dc2e9d2a8",
            "success": true,
            "run_directory": ".certora_internal/24_03_17_01_24_15_657/.certora_sources",
            "rule_report_link": "https://prover.certora.com/output/686351/32f4d94f79ff4d8889ea4896068860f2?anonymousKey=a4098599ac655b9cd7e6d85af1bd442dc2e9d2a8"
        }
    ]
}