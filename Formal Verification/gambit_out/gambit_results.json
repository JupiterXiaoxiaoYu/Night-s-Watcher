[
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        /// RequireMutation(`balances[src] >= wad` |==> `false`) of: `require(balances[src] >= wad, \"insufficient-balance\");`\n+        require(false, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "1",
    "name": "mutants/1/ERC20.sol",
    "original": "ERC20.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        /// AssignmentMutation(`balances[src].sub(wad)` |==> `1`) of: `balances[src] = balances[src].sub(wad);`\n+        balances[src] = 1;\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "2",
    "name": "mutants/2/ERC20.sol",
    "original": "ERC20.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        /// AssignmentMutation(`wad` |==> `0`) of: `allowance[src][usr] = wad;`\n+        allowance[src][usr] = 0;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "3",
    "name": "mutants/3/ERC20.sol",
    "original": "ERC20.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        /// AssignmentMutation(`balances[usr].add(wad)` |==> `0`) of: `balances[usr] = balances[usr].add(wad);`\n+        balances[usr] = 0;\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "4",
    "name": "mutants/4/ERC20.sol",
    "original": "ERC20.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        /// AssignmentMutation(`balances[usr].add(wad)` |==> `1`) of: `balances[usr] = balances[usr].add(wad);`\n+        balances[usr] = 1;\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "5",
    "name": "mutants/5/ERC20.sol",
    "original": "ERC20.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        /// AssignmentMutation(`balances[usr].sub(wad)` |==> `0`) of: `balances[usr] = balances[usr].sub(wad);`\n+        balances[usr] = 0;\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "6",
    "name": "mutants/6/ERC20.sol",
    "original": "ERC20.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        /// AssignmentMutation(`balances[usr].sub(wad)` |==> `1`) of: `balances[usr] = balances[usr].sub(wad);`\n+        balances[usr] = 1;\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "7",
    "name": "mutants/7/ERC20.sol",
    "original": "ERC20.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        /// AssignmentMutation(`_totalSupply.sub(wad)` |==> `1`) of: `_totalSupply = _totalSupply.sub(wad);`\n+        _totalSupply = 1;\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "8",
    "name": "mutants/8/ERC20.sol",
    "original": "ERC20.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        /// AssignmentMutation(`balances[src].sub(wad)` |==> `1`) of: `balances[src] = balances[src].sub(wad);`\n+        balances[src] = 1;\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "9",
    "name": "mutants/9/ERC20.sol",
    "original": "ERC20.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,82 +1,83 @@\n-// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-import {SafeMath} from \"./SafeMath.sol\";\r\n-\r\n-contract ERC20  {\r\n-    // --- ERC20 Data ---\r\n-    using SafeMath for uint;\r\n-    string  public constant name = \"Token\";\r\n-    string  public constant symbol = \"TKN\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 internal _totalSupply;\r\n-\r\n-    mapping (address => uint)                      internal balances;\r\n-    mapping (address => mapping (address => uint)) internal allowance;\r\n-\r\n-    event Approval(address indexed src, address indexed guy, uint wad);\r\n-    event Transfer(address indexed src, address indexed dst, uint wad);\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint initTotalSupply) {\r\n-        _totalSupply = initTotalSupply;\r\n-        balances[msg.sender] = _totalSupply;\r\n-        emit Transfer(address(0), msg.sender, _totalSupply);\r\n-    }\r\n-\r\n-\r\n-    // --- Token ---\r\n-    function transfer(address dst, uint wad) virtual public returns (bool) {\r\n-        return _transfer(msg.sender, dst, wad);\r\n-    }\r\n-\r\n-    function totalSupply() virtual public view returns (uint) {\r\n-        return _totalSupply;\r\n-    }\r\n-\r\n-    function balanceOf(address guy) virtual public view returns (uint) {\r\n-        return balances[guy];\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address usr, uint wad) virtual public returns (bool) {\r\n-        return _approve(msg.sender, usr, wad);\r\n-    }\r\n-\r\n-    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\r\n-        allowance[src][usr] = wad;\r\n-        emit Approval(src, usr, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _mint(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].add(wad);\r\n-        _totalSupply = _totalSupply.add(wad);\r\n-        emit Transfer(address(0), usr, wad);\r\n-    }\r\n-\r\n-    function _burn(address usr, uint wad) virtual internal {\r\n-        balances[usr] = balances[usr].sub(wad);\r\n-        _totalSupply = _totalSupply.sub(wad);\r\n-        emit Transfer(usr, address(0), wad);\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+import {SafeMath} from \"./SafeMath.sol\";\n+\n+contract ERC20  {\n+    // --- ERC20 Data ---\n+    using SafeMath for uint;\n+    string  public constant name = \"Token\";\n+    string  public constant symbol = \"TKN\";\n+    uint8   public decimals = 18;\n+    uint256 internal _totalSupply;\n+\n+    mapping (address => uint)                      internal balances;\n+    mapping (address => mapping (address => uint)) internal allowance;\n+\n+    event Approval(address indexed src, address indexed guy, uint wad);\n+    event Transfer(address indexed src, address indexed dst, uint wad);\n+\n+    // --- Init ---\n+    constructor(uint initTotalSupply) {\n+        _totalSupply = initTotalSupply;\n+        balances[msg.sender] = _totalSupply;\n+        emit Transfer(address(0), msg.sender, _totalSupply);\n+    }\n+\n+\n+    // --- Token ---\n+    function transfer(address dst, uint wad) virtual public returns (bool) {\n+        return _transfer(msg.sender, dst, wad);\n+    }\n+\n+    function totalSupply() virtual public view returns (uint) {\n+        return _totalSupply;\n+    }\n+\n+    function balanceOf(address guy) virtual public view returns (uint) {\n+        return balances[guy];\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function approve(address usr, uint wad) virtual public returns (bool) {\n+        return _approve(msg.sender, usr, wad);\n+    }\n+\n+    function _approve(address src, address usr, uint wad) virtual internal returns (bool){\n+        allowance[src][usr] = wad;\n+        emit Approval(src, usr, wad);\n+        return true;\n+    }\n+\n+    function _mint(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].add(wad);\n+        _totalSupply = _totalSupply.add(wad);\n+        emit Transfer(address(0), usr, wad);\n+    }\n+\n+    function _burn(address usr, uint wad) virtual internal {\n+        balances[usr] = balances[usr].sub(wad);\n+        _totalSupply = _totalSupply.sub(wad);\n+        emit Transfer(usr, address(0), wad);\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) virtual internal returns (bool){\n+        balances[src] = balances[src].sub(wad);\n+        /// AssignmentMutation(`balances[dst].add(wad)` |==> `0`) of: `balances[dst] = balances[dst].add(wad);`\n+        balances[dst] = 0;\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "10",
    "name": "mutants/10/ERC20.sol",
    "original": "ERC20.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,75 +1,76 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB1_Rebasing is ERC20 {\r\n-    // --- Access Control ---\r\n-    using SafeMath for uint;\r\n-    address owner;\r\n-    uint256 public gonsPerFragment = 1e6;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-    event Rebase(uint256 supply);\r\n-\r\n-    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    function balanceOf(address who)\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return balances[who].div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function totalSupply()\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return _totalSupply.div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function rebase(uint256 _newGonsPerFragment)\r\n-        external\r\n-        auth\r\n-        returns (uint256)\r\n-    {\r\n-        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\r\n-        gonsPerFragment = _newGonsPerFragment;\r\n-        emit Rebase(totalSupply());\r\n-        return totalSupply();\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        require(balanceOf(src) >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) override internal returns (bool){\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-\r\n-    }\r\n-\r\n-    function getGonsPerFragment() public view returns(uint256){\r\n-        return gonsPerFragment;\r\n-    }\r\n-\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB1_Rebasing is ERC20 {\n+    // --- Access Control ---\n+    using SafeMath for uint;\n+    address owner;\n+    uint256 public gonsPerFragment = 1e6;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+    event Rebase(uint256 supply);\n+\n+    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    function balanceOf(address who)\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return balances[who].div(gonsPerFragment);\n+    }\n+\n+    function totalSupply()\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return _totalSupply.div(gonsPerFragment);\n+    }\n+\n+    function rebase(uint256 _newGonsPerFragment)\n+        external\n+        auth\n+        returns (uint256)\n+    {\n+        /// RequireMutation(`_newGonsPerFragment != 0` |==> `true`) of: `require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");`\n+        require(true, \"new-gons-per-fragment-is-zero\");\n+        gonsPerFragment = _newGonsPerFragment;\n+        emit Rebase(totalSupply());\n+        return totalSupply();\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        require(balanceOf(src) >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) override internal returns (bool){\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+\n+    }\n+\n+    function getGonsPerFragment() public view returns(uint256){\n+        return gonsPerFragment;\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "11",
    "name": "mutants/11/TCB1_Rebasing.sol",
    "original": "TCB1_Rebasing.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,75 +1,76 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB1_Rebasing is ERC20 {\r\n-    // --- Access Control ---\r\n-    using SafeMath for uint;\r\n-    address owner;\r\n-    uint256 public gonsPerFragment = 1e6;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-    event Rebase(uint256 supply);\r\n-\r\n-    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    function balanceOf(address who)\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return balances[who].div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function totalSupply()\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return _totalSupply.div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function rebase(uint256 _newGonsPerFragment)\r\n-        external\r\n-        auth\r\n-        returns (uint256)\r\n-    {\r\n-        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\r\n-        gonsPerFragment = _newGonsPerFragment;\r\n-        emit Rebase(totalSupply());\r\n-        return totalSupply();\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        require(balanceOf(src) >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) override internal returns (bool){\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-\r\n-    }\r\n-\r\n-    function getGonsPerFragment() public view returns(uint256){\r\n-        return gonsPerFragment;\r\n-    }\r\n-\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB1_Rebasing is ERC20 {\n+    // --- Access Control ---\n+    using SafeMath for uint;\n+    address owner;\n+    uint256 public gonsPerFragment = 1e6;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+    event Rebase(uint256 supply);\n+\n+    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    function balanceOf(address who)\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return balances[who].div(gonsPerFragment);\n+    }\n+\n+    function totalSupply()\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return _totalSupply.div(gonsPerFragment);\n+    }\n+\n+    function rebase(uint256 _newGonsPerFragment)\n+        external\n+        auth\n+        returns (uint256)\n+    {\n+        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\n+        gonsPerFragment = _newGonsPerFragment;\n+        emit Rebase(totalSupply());\n+        return totalSupply();\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        require(balanceOf(src) >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            /// RequireMutation(`allowance[src][msg.sender] >= wad` |==> `true`) of: `require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");`\n+            require(true, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) override internal returns (bool){\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+\n+    }\n+\n+    function getGonsPerFragment() public view returns(uint256){\n+        return gonsPerFragment;\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "12",
    "name": "mutants/12/TCB1_Rebasing.sol",
    "original": "TCB1_Rebasing.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,75 +1,76 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB1_Rebasing is ERC20 {\r\n-    // --- Access Control ---\r\n-    using SafeMath for uint;\r\n-    address owner;\r\n-    uint256 public gonsPerFragment = 1e6;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-    event Rebase(uint256 supply);\r\n-\r\n-    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    function balanceOf(address who)\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return balances[who].div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function totalSupply()\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return _totalSupply.div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function rebase(uint256 _newGonsPerFragment)\r\n-        external\r\n-        auth\r\n-        returns (uint256)\r\n-    {\r\n-        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\r\n-        gonsPerFragment = _newGonsPerFragment;\r\n-        emit Rebase(totalSupply());\r\n-        return totalSupply();\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        require(balanceOf(src) >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) override internal returns (bool){\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-\r\n-    }\r\n-\r\n-    function getGonsPerFragment() public view returns(uint256){\r\n-        return gonsPerFragment;\r\n-    }\r\n-\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB1_Rebasing is ERC20 {\n+    // --- Access Control ---\n+    using SafeMath for uint;\n+    address owner;\n+    uint256 public gonsPerFragment = 1e6;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+    event Rebase(uint256 supply);\n+\n+    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    function balanceOf(address who)\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return balances[who].div(gonsPerFragment);\n+    }\n+\n+    function totalSupply()\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return _totalSupply.div(gonsPerFragment);\n+    }\n+\n+    function rebase(uint256 _newGonsPerFragment)\n+        external\n+        auth\n+        returns (uint256)\n+    {\n+        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\n+        gonsPerFragment = _newGonsPerFragment;\n+        emit Rebase(totalSupply());\n+        return totalSupply();\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        require(balanceOf(src) >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            /// RequireMutation(`allowance[src][msg.sender] >= wad` |==> `false`) of: `require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");`\n+            require(false, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) override internal returns (bool){\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+\n+    }\n+\n+    function getGonsPerFragment() public view returns(uint256){\n+        return gonsPerFragment;\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "13",
    "name": "mutants/13/TCB1_Rebasing.sol",
    "original": "TCB1_Rebasing.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,75 +1,76 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB1_Rebasing is ERC20 {\r\n-    // --- Access Control ---\r\n-    using SafeMath for uint;\r\n-    address owner;\r\n-    uint256 public gonsPerFragment = 1e6;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-    event Rebase(uint256 supply);\r\n-\r\n-    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    function balanceOf(address who)\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return balances[who].div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function totalSupply()\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return _totalSupply.div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function rebase(uint256 _newGonsPerFragment)\r\n-        external\r\n-        auth\r\n-        returns (uint256)\r\n-    {\r\n-        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\r\n-        gonsPerFragment = _newGonsPerFragment;\r\n-        emit Rebase(totalSupply());\r\n-        return totalSupply();\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        require(balanceOf(src) >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) override internal returns (bool){\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-\r\n-    }\r\n-\r\n-    function getGonsPerFragment() public view returns(uint256){\r\n-        return gonsPerFragment;\r\n-    }\r\n-\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB1_Rebasing is ERC20 {\n+    // --- Access Control ---\n+    using SafeMath for uint;\n+    address owner;\n+    uint256 public gonsPerFragment = 1e6;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+    event Rebase(uint256 supply);\n+\n+    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    function balanceOf(address who)\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return balances[who].div(gonsPerFragment);\n+    }\n+\n+    function totalSupply()\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return _totalSupply.div(gonsPerFragment);\n+    }\n+\n+    function rebase(uint256 _newGonsPerFragment)\n+        external\n+        auth\n+        returns (uint256)\n+    {\n+        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\n+        gonsPerFragment = _newGonsPerFragment;\n+        emit Rebase(totalSupply());\n+        return totalSupply();\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        require(balanceOf(src) >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        /// AssignmentMutation(`balances[src].sub(gonValue)` |==> `0`) of: `balances[src] = balances[src].sub(gonValue);`\n+        balances[src] = 0;\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) override internal returns (bool){\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+\n+    }\n+\n+    function getGonsPerFragment() public view returns(uint256){\n+        return gonsPerFragment;\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "14",
    "name": "mutants/14/TCB1_Rebasing.sol",
    "original": "TCB1_Rebasing.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,75 +1,76 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB1_Rebasing is ERC20 {\r\n-    // --- Access Control ---\r\n-    using SafeMath for uint;\r\n-    address owner;\r\n-    uint256 public gonsPerFragment = 1e6;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-    event Rebase(uint256 supply);\r\n-\r\n-    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    function balanceOf(address who)\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return balances[who].div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function totalSupply()\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return _totalSupply.div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function rebase(uint256 _newGonsPerFragment)\r\n-        external\r\n-        auth\r\n-        returns (uint256)\r\n-    {\r\n-        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\r\n-        gonsPerFragment = _newGonsPerFragment;\r\n-        emit Rebase(totalSupply());\r\n-        return totalSupply();\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        require(balanceOf(src) >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) override internal returns (bool){\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-\r\n-    }\r\n-\r\n-    function getGonsPerFragment() public view returns(uint256){\r\n-        return gonsPerFragment;\r\n-    }\r\n-\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB1_Rebasing is ERC20 {\n+    // --- Access Control ---\n+    using SafeMath for uint;\n+    address owner;\n+    uint256 public gonsPerFragment = 1e6;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+    event Rebase(uint256 supply);\n+\n+    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    function balanceOf(address who)\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return balances[who].div(gonsPerFragment);\n+    }\n+\n+    function totalSupply()\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return _totalSupply.div(gonsPerFragment);\n+    }\n+\n+    function rebase(uint256 _newGonsPerFragment)\n+        external\n+        auth\n+        returns (uint256)\n+    {\n+        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\n+        gonsPerFragment = _newGonsPerFragment;\n+        emit Rebase(totalSupply());\n+        return totalSupply();\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        require(balanceOf(src) >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        /// AssignmentMutation(`balances[src].sub(gonValue)` |==> `1`) of: `balances[src] = balances[src].sub(gonValue);`\n+        balances[src] = 1;\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) override internal returns (bool){\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+\n+    }\n+\n+    function getGonsPerFragment() public view returns(uint256){\n+        return gonsPerFragment;\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "15",
    "name": "mutants/15/TCB1_Rebasing.sol",
    "original": "TCB1_Rebasing.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,75 +1,76 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB1_Rebasing is ERC20 {\r\n-    // --- Access Control ---\r\n-    using SafeMath for uint;\r\n-    address owner;\r\n-    uint256 public gonsPerFragment = 1e6;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-    event Rebase(uint256 supply);\r\n-\r\n-    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    function balanceOf(address who)\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return balances[who].div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function totalSupply()\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return _totalSupply.div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function rebase(uint256 _newGonsPerFragment)\r\n-        external\r\n-        auth\r\n-        returns (uint256)\r\n-    {\r\n-        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\r\n-        gonsPerFragment = _newGonsPerFragment;\r\n-        emit Rebase(totalSupply());\r\n-        return totalSupply();\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        require(balanceOf(src) >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) override internal returns (bool){\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-\r\n-    }\r\n-\r\n-    function getGonsPerFragment() public view returns(uint256){\r\n-        return gonsPerFragment;\r\n-    }\r\n-\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB1_Rebasing is ERC20 {\n+    // --- Access Control ---\n+    using SafeMath for uint;\n+    address owner;\n+    uint256 public gonsPerFragment = 1e6;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+    event Rebase(uint256 supply);\n+\n+    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    function balanceOf(address who)\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return balances[who].div(gonsPerFragment);\n+    }\n+\n+    function totalSupply()\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return _totalSupply.div(gonsPerFragment);\n+    }\n+\n+    function rebase(uint256 _newGonsPerFragment)\n+        external\n+        auth\n+        returns (uint256)\n+    {\n+        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\n+        gonsPerFragment = _newGonsPerFragment;\n+        emit Rebase(totalSupply());\n+        return totalSupply();\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        require(balanceOf(src) >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(gonValue);\n+        /// AssignmentMutation(`balances[dst].add(gonValue)` |==> `0`) of: `balances[dst] = balances[dst].add(gonValue);`\n+        balances[dst] = 0;\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) override internal returns (bool){\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+\n+    }\n+\n+    function getGonsPerFragment() public view returns(uint256){\n+        return gonsPerFragment;\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "16",
    "name": "mutants/16/TCB1_Rebasing.sol",
    "original": "TCB1_Rebasing.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,75 +1,76 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB1_Rebasing is ERC20 {\r\n-    // --- Access Control ---\r\n-    using SafeMath for uint;\r\n-    address owner;\r\n-    uint256 public gonsPerFragment = 1e6;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-    event Rebase(uint256 supply);\r\n-\r\n-    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    function balanceOf(address who)\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return balances[who].div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function totalSupply()\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return _totalSupply.div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function rebase(uint256 _newGonsPerFragment)\r\n-        external\r\n-        auth\r\n-        returns (uint256)\r\n-    {\r\n-        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\r\n-        gonsPerFragment = _newGonsPerFragment;\r\n-        emit Rebase(totalSupply());\r\n-        return totalSupply();\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        require(balanceOf(src) >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) override internal returns (bool){\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-\r\n-    }\r\n-\r\n-    function getGonsPerFragment() public view returns(uint256){\r\n-        return gonsPerFragment;\r\n-    }\r\n-\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB1_Rebasing is ERC20 {\n+    // --- Access Control ---\n+    using SafeMath for uint;\n+    address owner;\n+    uint256 public gonsPerFragment = 1e6;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+    event Rebase(uint256 supply);\n+\n+    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    function balanceOf(address who)\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return balances[who].div(gonsPerFragment);\n+    }\n+\n+    function totalSupply()\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return _totalSupply.div(gonsPerFragment);\n+    }\n+\n+    function rebase(uint256 _newGonsPerFragment)\n+        external\n+        auth\n+        returns (uint256)\n+    {\n+        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\n+        gonsPerFragment = _newGonsPerFragment;\n+        emit Rebase(totalSupply());\n+        return totalSupply();\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        require(balanceOf(src) >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(gonValue);\n+        /// AssignmentMutation(`balances[dst].add(gonValue)` |==> `1`) of: `balances[dst] = balances[dst].add(gonValue);`\n+        balances[dst] = 1;\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) override internal returns (bool){\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+\n+    }\n+\n+    function getGonsPerFragment() public view returns(uint256){\n+        return gonsPerFragment;\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "17",
    "name": "mutants/17/TCB1_Rebasing.sol",
    "original": "TCB1_Rebasing.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,75 +1,76 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB1_Rebasing is ERC20 {\r\n-    // --- Access Control ---\r\n-    using SafeMath for uint;\r\n-    address owner;\r\n-    uint256 public gonsPerFragment = 1e6;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-    event Rebase(uint256 supply);\r\n-\r\n-    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    function balanceOf(address who)\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return balances[who].div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function totalSupply()\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return _totalSupply.div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function rebase(uint256 _newGonsPerFragment)\r\n-        external\r\n-        auth\r\n-        returns (uint256)\r\n-    {\r\n-        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\r\n-        gonsPerFragment = _newGonsPerFragment;\r\n-        emit Rebase(totalSupply());\r\n-        return totalSupply();\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        require(balanceOf(src) >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) override internal returns (bool){\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-\r\n-    }\r\n-\r\n-    function getGonsPerFragment() public view returns(uint256){\r\n-        return gonsPerFragment;\r\n-    }\r\n-\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB1_Rebasing is ERC20 {\n+    // --- Access Control ---\n+    using SafeMath for uint;\n+    address owner;\n+    uint256 public gonsPerFragment = 1e6;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+    event Rebase(uint256 supply);\n+\n+    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    function balanceOf(address who)\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return balances[who].div(gonsPerFragment);\n+    }\n+\n+    function totalSupply()\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return _totalSupply.div(gonsPerFragment);\n+    }\n+\n+    function rebase(uint256 _newGonsPerFragment)\n+        external\n+        auth\n+        returns (uint256)\n+    {\n+        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\n+        gonsPerFragment = _newGonsPerFragment;\n+        emit Rebase(totalSupply());\n+        return totalSupply();\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        require(balanceOf(src) >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) override internal returns (bool){\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        /// AssignmentMutation(`balances[src].sub(gonValue)` |==> `1`) of: `balances[src] = balances[src].sub(gonValue);`\n+        balances[src] = 1;\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+\n+    }\n+\n+    function getGonsPerFragment() public view returns(uint256){\n+        return gonsPerFragment;\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "18",
    "name": "mutants/18/TCB1_Rebasing.sol",
    "original": "TCB1_Rebasing.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,75 +1,76 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB1_Rebasing is ERC20 {\r\n-    // --- Access Control ---\r\n-    using SafeMath for uint;\r\n-    address owner;\r\n-    uint256 public gonsPerFragment = 1e6;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-    event Rebase(uint256 supply);\r\n-\r\n-    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    function balanceOf(address who)\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return balances[who].div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function totalSupply()\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return _totalSupply.div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function rebase(uint256 _newGonsPerFragment)\r\n-        external\r\n-        auth\r\n-        returns (uint256)\r\n-    {\r\n-        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\r\n-        gonsPerFragment = _newGonsPerFragment;\r\n-        emit Rebase(totalSupply());\r\n-        return totalSupply();\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        require(balanceOf(src) >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) override internal returns (bool){\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-\r\n-    }\r\n-\r\n-    function getGonsPerFragment() public view returns(uint256){\r\n-        return gonsPerFragment;\r\n-    }\r\n-\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB1_Rebasing is ERC20 {\n+    // --- Access Control ---\n+    using SafeMath for uint;\n+    address owner;\n+    uint256 public gonsPerFragment = 1e6;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+    event Rebase(uint256 supply);\n+\n+    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    function balanceOf(address who)\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return balances[who].div(gonsPerFragment);\n+    }\n+\n+    function totalSupply()\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return _totalSupply.div(gonsPerFragment);\n+    }\n+\n+    function rebase(uint256 _newGonsPerFragment)\n+        external\n+        auth\n+        returns (uint256)\n+    {\n+        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\n+        gonsPerFragment = _newGonsPerFragment;\n+        emit Rebase(totalSupply());\n+        return totalSupply();\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        require(balanceOf(src) >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) override internal returns (bool){\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        balances[src] = balances[src].sub(gonValue);\n+        /// AssignmentMutation(`balances[dst].add(gonValue)` |==> `0`) of: `balances[dst] = balances[dst].add(gonValue);`\n+        balances[dst] = 0;\n+        emit Transfer(src, dst, wad);\n+        return true;\n+\n+    }\n+\n+    function getGonsPerFragment() public view returns(uint256){\n+        return gonsPerFragment;\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "19",
    "name": "mutants/19/TCB1_Rebasing.sol",
    "original": "TCB1_Rebasing.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,75 +1,76 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB1_Rebasing is ERC20 {\r\n-    // --- Access Control ---\r\n-    using SafeMath for uint;\r\n-    address owner;\r\n-    uint256 public gonsPerFragment = 1e6;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-    event Rebase(uint256 supply);\r\n-\r\n-    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    function balanceOf(address who)\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return balances[who].div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function totalSupply()\r\n-        public\r\n-        view\r\n-        override\r\n-        returns (uint256)\r\n-    {\r\n-        return _totalSupply.div(gonsPerFragment);\r\n-    }\r\n-\r\n-    function rebase(uint256 _newGonsPerFragment)\r\n-        external\r\n-        auth\r\n-        returns (uint256)\r\n-    {\r\n-        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\r\n-        gonsPerFragment = _newGonsPerFragment;\r\n-        emit Rebase(totalSupply());\r\n-        return totalSupply();\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        require(balanceOf(src) >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _transfer(address src, address dst, uint wad) override internal returns (bool){\r\n-        uint256 gonValue = wad.mul(gonsPerFragment);\r\n-        balances[src] = balances[src].sub(gonValue);\r\n-        balances[dst] = balances[dst].add(gonValue);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-\r\n-    }\r\n-\r\n-    function getGonsPerFragment() public view returns(uint256){\r\n-        return gonsPerFragment;\r\n-    }\r\n-\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB1_Rebasing is ERC20 {\n+    // --- Access Control ---\n+    using SafeMath for uint;\n+    address owner;\n+    uint256 public gonsPerFragment = 1e6;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+    event Rebase(uint256 supply);\n+\n+    constructor(uint initTotalSupply) ERC20(initTotalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    function balanceOf(address who)\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return balances[who].div(gonsPerFragment);\n+    }\n+\n+    function totalSupply()\n+        public\n+        view\n+        override\n+        returns (uint256)\n+    {\n+        return _totalSupply.div(gonsPerFragment);\n+    }\n+\n+    function rebase(uint256 _newGonsPerFragment)\n+        external\n+        auth\n+        returns (uint256)\n+    {\n+        require(_newGonsPerFragment != 0, \"new-gons-per-fragment-is-zero\");\n+        gonsPerFragment = _newGonsPerFragment;\n+        emit Rebase(totalSupply());\n+        return totalSupply();\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        require(balanceOf(src) >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(gonValue);\n+        balances[dst] = balances[dst].add(gonValue);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    function _transfer(address src, address dst, uint wad) override internal returns (bool){\n+        uint256 gonValue = wad.mul(gonsPerFragment);\n+        balances[src] = balances[src].sub(gonValue);\n+        /// AssignmentMutation(`balances[dst].add(gonValue)` |==> `1`) of: `balances[dst] = balances[dst].add(gonValue);`\n+        balances[dst] = 1;\n+        emit Transfer(src, dst, wad);\n+        return true;\n+\n+    }\n+\n+    function getGonsPerFragment() public view returns(uint256){\n+        return gonsPerFragment;\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "20",
    "name": "mutants/20/TCB1_Rebasing.sol",
    "original": "TCB1_Rebasing.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,35 +1,36 @@\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB2_Deflation is ERC20 {\r\n-    using SafeMath for uint;\r\n-    uint immutable fee = 10;\r\n-    uint immutable feeDenominator = 1000;\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        require(wad > 0, \"zero-value-transfer\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        uint feeAmount = wad.mul(fee).div(feeDenominator);\r\n-        uint wadAfterFee = wad.sub(feeAmount);\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wadAfterFee);\r\n-        // Instead of transferring fee to address(0), we subtract it from the total supply\r\n-        _totalSupply = _totalSupply.sub(feeAmount);\r\n-\r\n-        emit Transfer(src, dst, wadAfterFee);\r\n-        // This event logs the fee burn\r\n-        emit Transfer(src, address(0), feeAmount);\r\n-        return true;\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: AGPL-3.0-only\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB2_Deflation is ERC20 {\n+    using SafeMath for uint;\n+    uint immutable fee = 10;\n+    uint immutable feeDenominator = 1000;\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        /// RequireMutation(`balances[src] >= wad` |==> `false`) of: `require(balances[src] >= wad, \"insufficient-balance\");`\n+        require(false, \"insufficient-balance\");\n+        require(wad > 0, \"zero-value-transfer\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        uint feeAmount = wad.mul(fee).div(feeDenominator);\n+        uint wadAfterFee = wad.sub(feeAmount);\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wadAfterFee);\n+        // Instead of transferring fee to address(0), we subtract it from the total supply\n+        _totalSupply = _totalSupply.sub(feeAmount);\n+\n+        emit Transfer(src, dst, wadAfterFee);\n+        // This event logs the fee burn\n+        emit Transfer(src, address(0), feeAmount);\n+        return true;\n+    }\n+}\n",
    "id": "21",
    "name": "mutants/21/TCB2_Deflation.sol",
    "original": "TCB2_Deflation.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,35 +1,36 @@\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB2_Deflation is ERC20 {\r\n-    using SafeMath for uint;\r\n-    uint immutable fee = 10;\r\n-    uint immutable feeDenominator = 1000;\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        require(wad > 0, \"zero-value-transfer\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        uint feeAmount = wad.mul(fee).div(feeDenominator);\r\n-        uint wadAfterFee = wad.sub(feeAmount);\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wadAfterFee);\r\n-        // Instead of transferring fee to address(0), we subtract it from the total supply\r\n-        _totalSupply = _totalSupply.sub(feeAmount);\r\n-\r\n-        emit Transfer(src, dst, wadAfterFee);\r\n-        // This event logs the fee burn\r\n-        emit Transfer(src, address(0), feeAmount);\r\n-        return true;\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: AGPL-3.0-only\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB2_Deflation is ERC20 {\n+    using SafeMath for uint;\n+    uint immutable fee = 10;\n+    uint immutable feeDenominator = 1000;\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        /// RequireMutation(`wad > 0` |==> `false`) of: `require(wad > 0, \"zero-value-transfer\");`\n+        require(false, \"zero-value-transfer\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        uint feeAmount = wad.mul(fee).div(feeDenominator);\n+        uint wadAfterFee = wad.sub(feeAmount);\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wadAfterFee);\n+        // Instead of transferring fee to address(0), we subtract it from the total supply\n+        _totalSupply = _totalSupply.sub(feeAmount);\n+\n+        emit Transfer(src, dst, wadAfterFee);\n+        // This event logs the fee burn\n+        emit Transfer(src, address(0), feeAmount);\n+        return true;\n+    }\n+}\n",
    "id": "22",
    "name": "mutants/22/TCB2_Deflation.sol",
    "original": "TCB2_Deflation.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,35 +1,36 @@\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB2_Deflation is ERC20 {\r\n-    using SafeMath for uint;\r\n-    uint immutable fee = 10;\r\n-    uint immutable feeDenominator = 1000;\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        require(wad > 0, \"zero-value-transfer\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        uint feeAmount = wad.mul(fee).div(feeDenominator);\r\n-        uint wadAfterFee = wad.sub(feeAmount);\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wadAfterFee);\r\n-        // Instead of transferring fee to address(0), we subtract it from the total supply\r\n-        _totalSupply = _totalSupply.sub(feeAmount);\r\n-\r\n-        emit Transfer(src, dst, wadAfterFee);\r\n-        // This event logs the fee burn\r\n-        emit Transfer(src, address(0), feeAmount);\r\n-        return true;\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: AGPL-3.0-only\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB2_Deflation is ERC20 {\n+    using SafeMath for uint;\n+    uint immutable fee = 10;\n+    uint immutable feeDenominator = 1000;\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        require(wad > 0, \"zero-value-transfer\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            /// RequireMutation(`allowance[src][msg.sender] >= wad` |==> `true`) of: `require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");`\n+            require(true, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        uint feeAmount = wad.mul(fee).div(feeDenominator);\n+        uint wadAfterFee = wad.sub(feeAmount);\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wadAfterFee);\n+        // Instead of transferring fee to address(0), we subtract it from the total supply\n+        _totalSupply = _totalSupply.sub(feeAmount);\n+\n+        emit Transfer(src, dst, wadAfterFee);\n+        // This event logs the fee burn\n+        emit Transfer(src, address(0), feeAmount);\n+        return true;\n+    }\n+}\n",
    "id": "23",
    "name": "mutants/23/TCB2_Deflation.sol",
    "original": "TCB2_Deflation.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,35 +1,36 @@\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB2_Deflation is ERC20 {\r\n-    using SafeMath for uint;\r\n-    uint immutable fee = 10;\r\n-    uint immutable feeDenominator = 1000;\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        require(wad > 0, \"zero-value-transfer\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        uint feeAmount = wad.mul(fee).div(feeDenominator);\r\n-        uint wadAfterFee = wad.sub(feeAmount);\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wadAfterFee);\r\n-        // Instead of transferring fee to address(0), we subtract it from the total supply\r\n-        _totalSupply = _totalSupply.sub(feeAmount);\r\n-\r\n-        emit Transfer(src, dst, wadAfterFee);\r\n-        // This event logs the fee burn\r\n-        emit Transfer(src, address(0), feeAmount);\r\n-        return true;\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: AGPL-3.0-only\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB2_Deflation is ERC20 {\n+    using SafeMath for uint;\n+    uint immutable fee = 10;\n+    uint immutable feeDenominator = 1000;\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        require(wad > 0, \"zero-value-transfer\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            /// RequireMutation(`allowance[src][msg.sender] >= wad` |==> `false`) of: `require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");`\n+            require(false, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        uint feeAmount = wad.mul(fee).div(feeDenominator);\n+        uint wadAfterFee = wad.sub(feeAmount);\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wadAfterFee);\n+        // Instead of transferring fee to address(0), we subtract it from the total supply\n+        _totalSupply = _totalSupply.sub(feeAmount);\n+\n+        emit Transfer(src, dst, wadAfterFee);\n+        // This event logs the fee burn\n+        emit Transfer(src, address(0), feeAmount);\n+        return true;\n+    }\n+}\n",
    "id": "24",
    "name": "mutants/24/TCB2_Deflation.sol",
    "original": "TCB2_Deflation.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,35 +1,36 @@\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB2_Deflation is ERC20 {\r\n-    using SafeMath for uint;\r\n-    uint immutable fee = 10;\r\n-    uint immutable feeDenominator = 1000;\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        require(wad > 0, \"zero-value-transfer\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        uint feeAmount = wad.mul(fee).div(feeDenominator);\r\n-        uint wadAfterFee = wad.sub(feeAmount);\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wadAfterFee);\r\n-        // Instead of transferring fee to address(0), we subtract it from the total supply\r\n-        _totalSupply = _totalSupply.sub(feeAmount);\r\n-\r\n-        emit Transfer(src, dst, wadAfterFee);\r\n-        // This event logs the fee burn\r\n-        emit Transfer(src, address(0), feeAmount);\r\n-        return true;\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: AGPL-3.0-only\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB2_Deflation is ERC20 {\n+    using SafeMath for uint;\n+    uint immutable fee = 10;\n+    uint immutable feeDenominator = 1000;\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        require(wad > 0, \"zero-value-transfer\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            /// AssignmentMutation(`allowance[src][msg.sender].sub(wad)` |==> `1`) of: `allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);`\n+            allowance[src][msg.sender] = 1;\n+        }\n+        uint feeAmount = wad.mul(fee).div(feeDenominator);\n+        uint wadAfterFee = wad.sub(feeAmount);\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wadAfterFee);\n+        // Instead of transferring fee to address(0), we subtract it from the total supply\n+        _totalSupply = _totalSupply.sub(feeAmount);\n+\n+        emit Transfer(src, dst, wadAfterFee);\n+        // This event logs the fee burn\n+        emit Transfer(src, address(0), feeAmount);\n+        return true;\n+    }\n+}\n",
    "id": "25",
    "name": "mutants/25/TCB2_Deflation.sol",
    "original": "TCB2_Deflation.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,35 +1,36 @@\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB2_Deflation is ERC20 {\r\n-    using SafeMath for uint;\r\n-    uint immutable fee = 10;\r\n-    uint immutable feeDenominator = 1000;\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        require(wad > 0, \"zero-value-transfer\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        uint feeAmount = wad.mul(fee).div(feeDenominator);\r\n-        uint wadAfterFee = wad.sub(feeAmount);\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wadAfterFee);\r\n-        // Instead of transferring fee to address(0), we subtract it from the total supply\r\n-        _totalSupply = _totalSupply.sub(feeAmount);\r\n-\r\n-        emit Transfer(src, dst, wadAfterFee);\r\n-        // This event logs the fee burn\r\n-        emit Transfer(src, address(0), feeAmount);\r\n-        return true;\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: AGPL-3.0-only\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB2_Deflation is ERC20 {\n+    using SafeMath for uint;\n+    uint immutable fee = 10;\n+    uint immutable feeDenominator = 1000;\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        require(wad > 0, \"zero-value-transfer\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        uint feeAmount = wad.mul(fee).div(feeDenominator);\n+        uint wadAfterFee = wad.sub(feeAmount);\n+        /// AssignmentMutation(`balances[src].sub(wad)` |==> `0`) of: `balances[src] = balances[src].sub(wad);`\n+        balances[src] = 0;\n+        balances[dst] = balances[dst].add(wadAfterFee);\n+        // Instead of transferring fee to address(0), we subtract it from the total supply\n+        _totalSupply = _totalSupply.sub(feeAmount);\n+\n+        emit Transfer(src, dst, wadAfterFee);\n+        // This event logs the fee burn\n+        emit Transfer(src, address(0), feeAmount);\n+        return true;\n+    }\n+}\n",
    "id": "26",
    "name": "mutants/26/TCB2_Deflation.sol",
    "original": "TCB2_Deflation.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,35 +1,36 @@\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB2_Deflation is ERC20 {\r\n-    using SafeMath for uint;\r\n-    uint immutable fee = 10;\r\n-    uint immutable feeDenominator = 1000;\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        require(wad > 0, \"zero-value-transfer\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        uint feeAmount = wad.mul(fee).div(feeDenominator);\r\n-        uint wadAfterFee = wad.sub(feeAmount);\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wadAfterFee);\r\n-        // Instead of transferring fee to address(0), we subtract it from the total supply\r\n-        _totalSupply = _totalSupply.sub(feeAmount);\r\n-\r\n-        emit Transfer(src, dst, wadAfterFee);\r\n-        // This event logs the fee burn\r\n-        emit Transfer(src, address(0), feeAmount);\r\n-        return true;\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: AGPL-3.0-only\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB2_Deflation is ERC20 {\n+    using SafeMath for uint;\n+    uint immutable fee = 10;\n+    uint immutable feeDenominator = 1000;\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        require(wad > 0, \"zero-value-transfer\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        uint feeAmount = wad.mul(fee).div(feeDenominator);\n+        uint wadAfterFee = wad.sub(feeAmount);\n+        balances[src] = balances[src].sub(wad);\n+        /// AssignmentMutation(`balances[dst].add(wadAfterFee)` |==> `0`) of: `balances[dst] = balances[dst].add(wadAfterFee);`\n+        balances[dst] = 0;\n+        // Instead of transferring fee to address(0), we subtract it from the total supply\n+        _totalSupply = _totalSupply.sub(feeAmount);\n+\n+        emit Transfer(src, dst, wadAfterFee);\n+        // This event logs the fee burn\n+        emit Transfer(src, address(0), feeAmount);\n+        return true;\n+    }\n+}\n",
    "id": "27",
    "name": "mutants/27/TCB2_Deflation.sol",
    "original": "TCB2_Deflation.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,35 +1,36 @@\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB2_Deflation is ERC20 {\r\n-    using SafeMath for uint;\r\n-    uint immutable fee = 10;\r\n-    uint immutable feeDenominator = 1000;\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        require(wad > 0, \"zero-value-transfer\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        uint feeAmount = wad.mul(fee).div(feeDenominator);\r\n-        uint wadAfterFee = wad.sub(feeAmount);\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wadAfterFee);\r\n-        // Instead of transferring fee to address(0), we subtract it from the total supply\r\n-        _totalSupply = _totalSupply.sub(feeAmount);\r\n-\r\n-        emit Transfer(src, dst, wadAfterFee);\r\n-        // This event logs the fee burn\r\n-        emit Transfer(src, address(0), feeAmount);\r\n-        return true;\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: AGPL-3.0-only\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB2_Deflation is ERC20 {\n+    using SafeMath for uint;\n+    uint immutable fee = 10;\n+    uint immutable feeDenominator = 1000;\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        require(wad > 0, \"zero-value-transfer\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        uint feeAmount = wad.mul(fee).div(feeDenominator);\n+        uint wadAfterFee = wad.sub(feeAmount);\n+        balances[src] = balances[src].sub(wad);\n+        /// AssignmentMutation(`balances[dst].add(wadAfterFee)` |==> `1`) of: `balances[dst] = balances[dst].add(wadAfterFee);`\n+        balances[dst] = 1;\n+        // Instead of transferring fee to address(0), we subtract it from the total supply\n+        _totalSupply = _totalSupply.sub(feeAmount);\n+\n+        emit Transfer(src, dst, wadAfterFee);\n+        // This event logs the fee burn\n+        emit Transfer(src, address(0), feeAmount);\n+        return true;\n+    }\n+}\n",
    "id": "28",
    "name": "mutants/28/TCB2_Deflation.sol",
    "original": "TCB2_Deflation.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,35 +1,36 @@\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB2_Deflation is ERC20 {\r\n-    using SafeMath for uint;\r\n-    uint immutable fee = 10;\r\n-    uint immutable feeDenominator = 1000;\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        require(wad > 0, \"zero-value-transfer\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        uint feeAmount = wad.mul(fee).div(feeDenominator);\r\n-        uint wadAfterFee = wad.sub(feeAmount);\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wadAfterFee);\r\n-        // Instead of transferring fee to address(0), we subtract it from the total supply\r\n-        _totalSupply = _totalSupply.sub(feeAmount);\r\n-\r\n-        emit Transfer(src, dst, wadAfterFee);\r\n-        // This event logs the fee burn\r\n-        emit Transfer(src, address(0), feeAmount);\r\n-        return true;\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: AGPL-3.0-only\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB2_Deflation is ERC20 {\n+    using SafeMath for uint;\n+    uint immutable fee = 10;\n+    uint immutable feeDenominator = 1000;\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        require(wad > 0, \"zero-value-transfer\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        uint feeAmount = wad.mul(fee).div(feeDenominator);\n+        uint wadAfterFee = wad.sub(feeAmount);\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wadAfterFee);\n+        // Instead of transferring fee to address(0), we subtract it from the total supply\n+        /// AssignmentMutation(`_totalSupply.sub(feeAmount)` |==> `0`) of: `_totalSupply = _totalSupply.sub(feeAmount);`\n+        _totalSupply = 0;\n+\n+        emit Transfer(src, dst, wadAfterFee);\n+        // This event logs the fee burn\n+        emit Transfer(src, address(0), feeAmount);\n+        return true;\n+    }\n+}\n",
    "id": "29",
    "name": "mutants/29/TCB2_Deflation.sol",
    "original": "TCB2_Deflation.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,35 +1,36 @@\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB2_Deflation is ERC20 {\r\n-    using SafeMath for uint;\r\n-    uint immutable fee = 10;\r\n-    uint immutable feeDenominator = 1000;\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        require(wad > 0, \"zero-value-transfer\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        uint feeAmount = wad.mul(fee).div(feeDenominator);\r\n-        uint wadAfterFee = wad.sub(feeAmount);\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wadAfterFee);\r\n-        // Instead of transferring fee to address(0), we subtract it from the total supply\r\n-        _totalSupply = _totalSupply.sub(feeAmount);\r\n-\r\n-        emit Transfer(src, dst, wadAfterFee);\r\n-        // This event logs the fee burn\r\n-        emit Transfer(src, address(0), feeAmount);\r\n-        return true;\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: AGPL-3.0-only\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB2_Deflation is ERC20 {\n+    using SafeMath for uint;\n+    uint immutable fee = 10;\n+    uint immutable feeDenominator = 1000;\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        require(wad > 0, \"zero-value-transfer\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        uint feeAmount = wad.mul(fee).div(feeDenominator);\n+        uint wadAfterFee = wad.sub(feeAmount);\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wadAfterFee);\n+        // Instead of transferring fee to address(0), we subtract it from the total supply\n+        /// AssignmentMutation(`_totalSupply.sub(feeAmount)` |==> `1`) of: `_totalSupply = _totalSupply.sub(feeAmount);`\n+        _totalSupply = 1;\n+\n+        emit Transfer(src, dst, wadAfterFee);\n+        // This event logs the fee burn\n+        emit Transfer(src, address(0), feeAmount);\n+        return true;\n+    }\n+}\n",
    "id": "30",
    "name": "mutants/30/TCB2_Deflation.sol",
    "original": "TCB2_Deflation.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,67 +1,68 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity ^0.8.8;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB3_Inflation_Airdrop is ERC20 {\r\n-    uint256 _airdropAmount;\r\n-    uint256 _cutoff = _airdropAmount * 10000;\r\n-    uint256 _outAmount = 0;\r\n-    using SafeMath for uint;\r\n-\r\n-    mapping(address => bool) initialized;\r\n-\r\n-    constructor(\r\n-        uint256 airdropAmount\r\n-    ) ERC20(airdropAmount * 19000000) {\r\n-        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\r\n-        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\r\n-        initialized[msg.sender] = true;\r\n-        _airdropAmount = airdropAmount;\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        initialize(src);\r\n-        initialize(dst);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    // internal privats\r\n-    function initialize(address _address) internal returns (bool success) {\r\n-        if (_outAmount < _cutoff && !initialized[_address]) {\r\n-            initialized[_address] = true;\r\n-            balances[_address].add(_airdropAmount);\r\n-            _outAmount = _outAmount.add(_airdropAmount);\r\n-            _totalSupply = _totalSupply.add(_airdropAmount);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    function getAirDropAmount() public view returns(uint256 amount){\r\n-        return _airdropAmount;\r\n-    }\r\n-\r\n-    function getCutoff() public view returns(uint256 amount){\r\n-        return _cutoff;\r\n-    }\r\n-\r\n-    function isInitialized(address _address) public view returns(bool success){\r\n-        return initialized[_address];\r\n-    }\r\n-\r\n-    function getOutAmount() public view returns(uint256 amount){\r\n-        return _outAmount;\r\n-    }\r\n-    \r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity ^0.8.8;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB3_Inflation_Airdrop is ERC20 {\n+    uint256 _airdropAmount;\n+    uint256 _cutoff = _airdropAmount * 10000;\n+    uint256 _outAmount = 0;\n+    using SafeMath for uint;\n+\n+    mapping(address => bool) initialized;\n+\n+    constructor(\n+        uint256 airdropAmount\n+    ) ERC20(airdropAmount * 19000000) {\n+        /// RequireMutation(`airdropAmount > 0` |==> `false`) of: `require(airdropAmount > 0, \"airdrop-amount-is-zero\");`\n+        require(false, \"airdrop-amount-is-zero\");\n+        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\n+        initialized[msg.sender] = true;\n+        _airdropAmount = airdropAmount;\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        initialize(src);\n+        initialize(dst);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    // internal privats\n+    function initialize(address _address) internal returns (bool success) {\n+        if (_outAmount < _cutoff && !initialized[_address]) {\n+            initialized[_address] = true;\n+            balances[_address].add(_airdropAmount);\n+            _outAmount = _outAmount.add(_airdropAmount);\n+            _totalSupply = _totalSupply.add(_airdropAmount);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    function getAirDropAmount() public view returns(uint256 amount){\n+        return _airdropAmount;\n+    }\n+\n+    function getCutoff() public view returns(uint256 amount){\n+        return _cutoff;\n+    }\n+\n+    function isInitialized(address _address) public view returns(bool success){\n+        return initialized[_address];\n+    }\n+\n+    function getOutAmount() public view returns(uint256 amount){\n+        return _outAmount;\n+    }\n+    \n }\n\\ No newline at end of file\n",
    "id": "31",
    "name": "mutants/31/TCB3_Inflation_Airdrop.sol",
    "original": "TCB3_Inflation_Airdrop.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,67 +1,68 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity ^0.8.8;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB3_Inflation_Airdrop is ERC20 {\r\n-    uint256 _airdropAmount;\r\n-    uint256 _cutoff = _airdropAmount * 10000;\r\n-    uint256 _outAmount = 0;\r\n-    using SafeMath for uint;\r\n-\r\n-    mapping(address => bool) initialized;\r\n-\r\n-    constructor(\r\n-        uint256 airdropAmount\r\n-    ) ERC20(airdropAmount * 19000000) {\r\n-        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\r\n-        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\r\n-        initialized[msg.sender] = true;\r\n-        _airdropAmount = airdropAmount;\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        initialize(src);\r\n-        initialize(dst);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    // internal privats\r\n-    function initialize(address _address) internal returns (bool success) {\r\n-        if (_outAmount < _cutoff && !initialized[_address]) {\r\n-            initialized[_address] = true;\r\n-            balances[_address].add(_airdropAmount);\r\n-            _outAmount = _outAmount.add(_airdropAmount);\r\n-            _totalSupply = _totalSupply.add(_airdropAmount);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    function getAirDropAmount() public view returns(uint256 amount){\r\n-        return _airdropAmount;\r\n-    }\r\n-\r\n-    function getCutoff() public view returns(uint256 amount){\r\n-        return _cutoff;\r\n-    }\r\n-\r\n-    function isInitialized(address _address) public view returns(bool success){\r\n-        return initialized[_address];\r\n-    }\r\n-\r\n-    function getOutAmount() public view returns(uint256 amount){\r\n-        return _outAmount;\r\n-    }\r\n-    \r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity ^0.8.8;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB3_Inflation_Airdrop is ERC20 {\n+    uint256 _airdropAmount;\n+    uint256 _cutoff = _airdropAmount * 10000;\n+    uint256 _outAmount = 0;\n+    using SafeMath for uint;\n+\n+    mapping(address => bool) initialized;\n+\n+    constructor(\n+        uint256 airdropAmount\n+    ) ERC20(airdropAmount * 19000000) {\n+        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\n+        /// RequireMutation(`airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max` |==> `true`) of: `require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");`\n+        require(true, \"airdrop-amount-too-high\");\n+        initialized[msg.sender] = true;\n+        _airdropAmount = airdropAmount;\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        initialize(src);\n+        initialize(dst);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    // internal privats\n+    function initialize(address _address) internal returns (bool success) {\n+        if (_outAmount < _cutoff && !initialized[_address]) {\n+            initialized[_address] = true;\n+            balances[_address].add(_airdropAmount);\n+            _outAmount = _outAmount.add(_airdropAmount);\n+            _totalSupply = _totalSupply.add(_airdropAmount);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    function getAirDropAmount() public view returns(uint256 amount){\n+        return _airdropAmount;\n+    }\n+\n+    function getCutoff() public view returns(uint256 amount){\n+        return _cutoff;\n+    }\n+\n+    function isInitialized(address _address) public view returns(bool success){\n+        return initialized[_address];\n+    }\n+\n+    function getOutAmount() public view returns(uint256 amount){\n+        return _outAmount;\n+    }\n+    \n }\n\\ No newline at end of file\n",
    "id": "32",
    "name": "mutants/32/TCB3_Inflation_Airdrop.sol",
    "original": "TCB3_Inflation_Airdrop.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,67 +1,68 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity ^0.8.8;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB3_Inflation_Airdrop is ERC20 {\r\n-    uint256 _airdropAmount;\r\n-    uint256 _cutoff = _airdropAmount * 10000;\r\n-    uint256 _outAmount = 0;\r\n-    using SafeMath for uint;\r\n-\r\n-    mapping(address => bool) initialized;\r\n-\r\n-    constructor(\r\n-        uint256 airdropAmount\r\n-    ) ERC20(airdropAmount * 19000000) {\r\n-        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\r\n-        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\r\n-        initialized[msg.sender] = true;\r\n-        _airdropAmount = airdropAmount;\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        initialize(src);\r\n-        initialize(dst);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    // internal privats\r\n-    function initialize(address _address) internal returns (bool success) {\r\n-        if (_outAmount < _cutoff && !initialized[_address]) {\r\n-            initialized[_address] = true;\r\n-            balances[_address].add(_airdropAmount);\r\n-            _outAmount = _outAmount.add(_airdropAmount);\r\n-            _totalSupply = _totalSupply.add(_airdropAmount);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    function getAirDropAmount() public view returns(uint256 amount){\r\n-        return _airdropAmount;\r\n-    }\r\n-\r\n-    function getCutoff() public view returns(uint256 amount){\r\n-        return _cutoff;\r\n-    }\r\n-\r\n-    function isInitialized(address _address) public view returns(bool success){\r\n-        return initialized[_address];\r\n-    }\r\n-\r\n-    function getOutAmount() public view returns(uint256 amount){\r\n-        return _outAmount;\r\n-    }\r\n-    \r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity ^0.8.8;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB3_Inflation_Airdrop is ERC20 {\n+    uint256 _airdropAmount;\n+    uint256 _cutoff = _airdropAmount * 10000;\n+    uint256 _outAmount = 0;\n+    using SafeMath for uint;\n+\n+    mapping(address => bool) initialized;\n+\n+    constructor(\n+        uint256 airdropAmount\n+    ) ERC20(airdropAmount * 19000000) {\n+        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\n+        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\n+        initialized[msg.sender] = true;\n+        /// AssignmentMutation(`airdropAmount` |==> `0`) of: `_airdropAmount = airdropAmount;`\n+        _airdropAmount = 0;\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        initialize(src);\n+        initialize(dst);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    // internal privats\n+    function initialize(address _address) internal returns (bool success) {\n+        if (_outAmount < _cutoff && !initialized[_address]) {\n+            initialized[_address] = true;\n+            balances[_address].add(_airdropAmount);\n+            _outAmount = _outAmount.add(_airdropAmount);\n+            _totalSupply = _totalSupply.add(_airdropAmount);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    function getAirDropAmount() public view returns(uint256 amount){\n+        return _airdropAmount;\n+    }\n+\n+    function getCutoff() public view returns(uint256 amount){\n+        return _cutoff;\n+    }\n+\n+    function isInitialized(address _address) public view returns(bool success){\n+        return initialized[_address];\n+    }\n+\n+    function getOutAmount() public view returns(uint256 amount){\n+        return _outAmount;\n+    }\n+    \n }\n\\ No newline at end of file\n",
    "id": "33",
    "name": "mutants/33/TCB3_Inflation_Airdrop.sol",
    "original": "TCB3_Inflation_Airdrop.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,67 +1,68 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity ^0.8.8;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB3_Inflation_Airdrop is ERC20 {\r\n-    uint256 _airdropAmount;\r\n-    uint256 _cutoff = _airdropAmount * 10000;\r\n-    uint256 _outAmount = 0;\r\n-    using SafeMath for uint;\r\n-\r\n-    mapping(address => bool) initialized;\r\n-\r\n-    constructor(\r\n-        uint256 airdropAmount\r\n-    ) ERC20(airdropAmount * 19000000) {\r\n-        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\r\n-        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\r\n-        initialized[msg.sender] = true;\r\n-        _airdropAmount = airdropAmount;\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        initialize(src);\r\n-        initialize(dst);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    // internal privats\r\n-    function initialize(address _address) internal returns (bool success) {\r\n-        if (_outAmount < _cutoff && !initialized[_address]) {\r\n-            initialized[_address] = true;\r\n-            balances[_address].add(_airdropAmount);\r\n-            _outAmount = _outAmount.add(_airdropAmount);\r\n-            _totalSupply = _totalSupply.add(_airdropAmount);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    function getAirDropAmount() public view returns(uint256 amount){\r\n-        return _airdropAmount;\r\n-    }\r\n-\r\n-    function getCutoff() public view returns(uint256 amount){\r\n-        return _cutoff;\r\n-    }\r\n-\r\n-    function isInitialized(address _address) public view returns(bool success){\r\n-        return initialized[_address];\r\n-    }\r\n-\r\n-    function getOutAmount() public view returns(uint256 amount){\r\n-        return _outAmount;\r\n-    }\r\n-    \r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity ^0.8.8;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB3_Inflation_Airdrop is ERC20 {\n+    uint256 _airdropAmount;\n+    uint256 _cutoff = _airdropAmount * 10000;\n+    uint256 _outAmount = 0;\n+    using SafeMath for uint;\n+\n+    mapping(address => bool) initialized;\n+\n+    constructor(\n+        uint256 airdropAmount\n+    ) ERC20(airdropAmount * 19000000) {\n+        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\n+        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\n+        initialized[msg.sender] = true;\n+        _airdropAmount = airdropAmount;\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        /// RequireMutation(`balances[src] >= wad` |==> `true`) of: `require(balances[src] >= wad, \"insufficient-balance\");`\n+        require(true, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        initialize(src);\n+        initialize(dst);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    // internal privats\n+    function initialize(address _address) internal returns (bool success) {\n+        if (_outAmount < _cutoff && !initialized[_address]) {\n+            initialized[_address] = true;\n+            balances[_address].add(_airdropAmount);\n+            _outAmount = _outAmount.add(_airdropAmount);\n+            _totalSupply = _totalSupply.add(_airdropAmount);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    function getAirDropAmount() public view returns(uint256 amount){\n+        return _airdropAmount;\n+    }\n+\n+    function getCutoff() public view returns(uint256 amount){\n+        return _cutoff;\n+    }\n+\n+    function isInitialized(address _address) public view returns(bool success){\n+        return initialized[_address];\n+    }\n+\n+    function getOutAmount() public view returns(uint256 amount){\n+        return _outAmount;\n+    }\n+    \n }\n\\ No newline at end of file\n",
    "id": "34",
    "name": "mutants/34/TCB3_Inflation_Airdrop.sol",
    "original": "TCB3_Inflation_Airdrop.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,67 +1,68 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity ^0.8.8;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB3_Inflation_Airdrop is ERC20 {\r\n-    uint256 _airdropAmount;\r\n-    uint256 _cutoff = _airdropAmount * 10000;\r\n-    uint256 _outAmount = 0;\r\n-    using SafeMath for uint;\r\n-\r\n-    mapping(address => bool) initialized;\r\n-\r\n-    constructor(\r\n-        uint256 airdropAmount\r\n-    ) ERC20(airdropAmount * 19000000) {\r\n-        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\r\n-        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\r\n-        initialized[msg.sender] = true;\r\n-        _airdropAmount = airdropAmount;\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        initialize(src);\r\n-        initialize(dst);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    // internal privats\r\n-    function initialize(address _address) internal returns (bool success) {\r\n-        if (_outAmount < _cutoff && !initialized[_address]) {\r\n-            initialized[_address] = true;\r\n-            balances[_address].add(_airdropAmount);\r\n-            _outAmount = _outAmount.add(_airdropAmount);\r\n-            _totalSupply = _totalSupply.add(_airdropAmount);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    function getAirDropAmount() public view returns(uint256 amount){\r\n-        return _airdropAmount;\r\n-    }\r\n-\r\n-    function getCutoff() public view returns(uint256 amount){\r\n-        return _cutoff;\r\n-    }\r\n-\r\n-    function isInitialized(address _address) public view returns(bool success){\r\n-        return initialized[_address];\r\n-    }\r\n-\r\n-    function getOutAmount() public view returns(uint256 amount){\r\n-        return _outAmount;\r\n-    }\r\n-    \r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity ^0.8.8;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB3_Inflation_Airdrop is ERC20 {\n+    uint256 _airdropAmount;\n+    uint256 _cutoff = _airdropAmount * 10000;\n+    uint256 _outAmount = 0;\n+    using SafeMath for uint;\n+\n+    mapping(address => bool) initialized;\n+\n+    constructor(\n+        uint256 airdropAmount\n+    ) ERC20(airdropAmount * 19000000) {\n+        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\n+        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\n+        initialized[msg.sender] = true;\n+        _airdropAmount = airdropAmount;\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            /// RequireMutation(`allowance[src][msg.sender] >= wad` |==> `true`) of: `require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");`\n+            require(true, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        initialize(src);\n+        initialize(dst);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    // internal privats\n+    function initialize(address _address) internal returns (bool success) {\n+        if (_outAmount < _cutoff && !initialized[_address]) {\n+            initialized[_address] = true;\n+            balances[_address].add(_airdropAmount);\n+            _outAmount = _outAmount.add(_airdropAmount);\n+            _totalSupply = _totalSupply.add(_airdropAmount);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    function getAirDropAmount() public view returns(uint256 amount){\n+        return _airdropAmount;\n+    }\n+\n+    function getCutoff() public view returns(uint256 amount){\n+        return _cutoff;\n+    }\n+\n+    function isInitialized(address _address) public view returns(bool success){\n+        return initialized[_address];\n+    }\n+\n+    function getOutAmount() public view returns(uint256 amount){\n+        return _outAmount;\n+    }\n+    \n }\n\\ No newline at end of file\n",
    "id": "35",
    "name": "mutants/35/TCB3_Inflation_Airdrop.sol",
    "original": "TCB3_Inflation_Airdrop.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,67 +1,68 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity ^0.8.8;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB3_Inflation_Airdrop is ERC20 {\r\n-    uint256 _airdropAmount;\r\n-    uint256 _cutoff = _airdropAmount * 10000;\r\n-    uint256 _outAmount = 0;\r\n-    using SafeMath for uint;\r\n-\r\n-    mapping(address => bool) initialized;\r\n-\r\n-    constructor(\r\n-        uint256 airdropAmount\r\n-    ) ERC20(airdropAmount * 19000000) {\r\n-        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\r\n-        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\r\n-        initialized[msg.sender] = true;\r\n-        _airdropAmount = airdropAmount;\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        initialize(src);\r\n-        initialize(dst);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    // internal privats\r\n-    function initialize(address _address) internal returns (bool success) {\r\n-        if (_outAmount < _cutoff && !initialized[_address]) {\r\n-            initialized[_address] = true;\r\n-            balances[_address].add(_airdropAmount);\r\n-            _outAmount = _outAmount.add(_airdropAmount);\r\n-            _totalSupply = _totalSupply.add(_airdropAmount);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    function getAirDropAmount() public view returns(uint256 amount){\r\n-        return _airdropAmount;\r\n-    }\r\n-\r\n-    function getCutoff() public view returns(uint256 amount){\r\n-        return _cutoff;\r\n-    }\r\n-\r\n-    function isInitialized(address _address) public view returns(bool success){\r\n-        return initialized[_address];\r\n-    }\r\n-\r\n-    function getOutAmount() public view returns(uint256 amount){\r\n-        return _outAmount;\r\n-    }\r\n-    \r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity ^0.8.8;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB3_Inflation_Airdrop is ERC20 {\n+    uint256 _airdropAmount;\n+    uint256 _cutoff = _airdropAmount * 10000;\n+    uint256 _outAmount = 0;\n+    using SafeMath for uint;\n+\n+    mapping(address => bool) initialized;\n+\n+    constructor(\n+        uint256 airdropAmount\n+    ) ERC20(airdropAmount * 19000000) {\n+        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\n+        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\n+        initialized[msg.sender] = true;\n+        _airdropAmount = airdropAmount;\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            /// AssignmentMutation(`allowance[src][msg.sender].sub(wad)` |==> `0`) of: `allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);`\n+            allowance[src][msg.sender] = 0;\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        initialize(src);\n+        initialize(dst);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    // internal privats\n+    function initialize(address _address) internal returns (bool success) {\n+        if (_outAmount < _cutoff && !initialized[_address]) {\n+            initialized[_address] = true;\n+            balances[_address].add(_airdropAmount);\n+            _outAmount = _outAmount.add(_airdropAmount);\n+            _totalSupply = _totalSupply.add(_airdropAmount);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    function getAirDropAmount() public view returns(uint256 amount){\n+        return _airdropAmount;\n+    }\n+\n+    function getCutoff() public view returns(uint256 amount){\n+        return _cutoff;\n+    }\n+\n+    function isInitialized(address _address) public view returns(bool success){\n+        return initialized[_address];\n+    }\n+\n+    function getOutAmount() public view returns(uint256 amount){\n+        return _outAmount;\n+    }\n+    \n }\n\\ No newline at end of file\n",
    "id": "36",
    "name": "mutants/36/TCB3_Inflation_Airdrop.sol",
    "original": "TCB3_Inflation_Airdrop.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,67 +1,68 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity ^0.8.8;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB3_Inflation_Airdrop is ERC20 {\r\n-    uint256 _airdropAmount;\r\n-    uint256 _cutoff = _airdropAmount * 10000;\r\n-    uint256 _outAmount = 0;\r\n-    using SafeMath for uint;\r\n-\r\n-    mapping(address => bool) initialized;\r\n-\r\n-    constructor(\r\n-        uint256 airdropAmount\r\n-    ) ERC20(airdropAmount * 19000000) {\r\n-        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\r\n-        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\r\n-        initialized[msg.sender] = true;\r\n-        _airdropAmount = airdropAmount;\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        initialize(src);\r\n-        initialize(dst);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    // internal privats\r\n-    function initialize(address _address) internal returns (bool success) {\r\n-        if (_outAmount < _cutoff && !initialized[_address]) {\r\n-            initialized[_address] = true;\r\n-            balances[_address].add(_airdropAmount);\r\n-            _outAmount = _outAmount.add(_airdropAmount);\r\n-            _totalSupply = _totalSupply.add(_airdropAmount);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    function getAirDropAmount() public view returns(uint256 amount){\r\n-        return _airdropAmount;\r\n-    }\r\n-\r\n-    function getCutoff() public view returns(uint256 amount){\r\n-        return _cutoff;\r\n-    }\r\n-\r\n-    function isInitialized(address _address) public view returns(bool success){\r\n-        return initialized[_address];\r\n-    }\r\n-\r\n-    function getOutAmount() public view returns(uint256 amount){\r\n-        return _outAmount;\r\n-    }\r\n-    \r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity ^0.8.8;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB3_Inflation_Airdrop is ERC20 {\n+    uint256 _airdropAmount;\n+    uint256 _cutoff = _airdropAmount * 10000;\n+    uint256 _outAmount = 0;\n+    using SafeMath for uint;\n+\n+    mapping(address => bool) initialized;\n+\n+    constructor(\n+        uint256 airdropAmount\n+    ) ERC20(airdropAmount * 19000000) {\n+        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\n+        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\n+        initialized[msg.sender] = true;\n+        _airdropAmount = airdropAmount;\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        /// AssignmentMutation(`balances[src].sub(wad)` |==> `0`) of: `balances[src] = balances[src].sub(wad);`\n+        balances[src] = 0;\n+        balances[dst] = balances[dst].add(wad);\n+        initialize(src);\n+        initialize(dst);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    // internal privats\n+    function initialize(address _address) internal returns (bool success) {\n+        if (_outAmount < _cutoff && !initialized[_address]) {\n+            initialized[_address] = true;\n+            balances[_address].add(_airdropAmount);\n+            _outAmount = _outAmount.add(_airdropAmount);\n+            _totalSupply = _totalSupply.add(_airdropAmount);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    function getAirDropAmount() public view returns(uint256 amount){\n+        return _airdropAmount;\n+    }\n+\n+    function getCutoff() public view returns(uint256 amount){\n+        return _cutoff;\n+    }\n+\n+    function isInitialized(address _address) public view returns(bool success){\n+        return initialized[_address];\n+    }\n+\n+    function getOutAmount() public view returns(uint256 amount){\n+        return _outAmount;\n+    }\n+    \n }\n\\ No newline at end of file\n",
    "id": "37",
    "name": "mutants/37/TCB3_Inflation_Airdrop.sol",
    "original": "TCB3_Inflation_Airdrop.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,67 +1,68 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity ^0.8.8;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB3_Inflation_Airdrop is ERC20 {\r\n-    uint256 _airdropAmount;\r\n-    uint256 _cutoff = _airdropAmount * 10000;\r\n-    uint256 _outAmount = 0;\r\n-    using SafeMath for uint;\r\n-\r\n-    mapping(address => bool) initialized;\r\n-\r\n-    constructor(\r\n-        uint256 airdropAmount\r\n-    ) ERC20(airdropAmount * 19000000) {\r\n-        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\r\n-        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\r\n-        initialized[msg.sender] = true;\r\n-        _airdropAmount = airdropAmount;\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        initialize(src);\r\n-        initialize(dst);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    // internal privats\r\n-    function initialize(address _address) internal returns (bool success) {\r\n-        if (_outAmount < _cutoff && !initialized[_address]) {\r\n-            initialized[_address] = true;\r\n-            balances[_address].add(_airdropAmount);\r\n-            _outAmount = _outAmount.add(_airdropAmount);\r\n-            _totalSupply = _totalSupply.add(_airdropAmount);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    function getAirDropAmount() public view returns(uint256 amount){\r\n-        return _airdropAmount;\r\n-    }\r\n-\r\n-    function getCutoff() public view returns(uint256 amount){\r\n-        return _cutoff;\r\n-    }\r\n-\r\n-    function isInitialized(address _address) public view returns(bool success){\r\n-        return initialized[_address];\r\n-    }\r\n-\r\n-    function getOutAmount() public view returns(uint256 amount){\r\n-        return _outAmount;\r\n-    }\r\n-    \r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity ^0.8.8;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB3_Inflation_Airdrop is ERC20 {\n+    uint256 _airdropAmount;\n+    uint256 _cutoff = _airdropAmount * 10000;\n+    uint256 _outAmount = 0;\n+    using SafeMath for uint;\n+\n+    mapping(address => bool) initialized;\n+\n+    constructor(\n+        uint256 airdropAmount\n+    ) ERC20(airdropAmount * 19000000) {\n+        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\n+        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\n+        initialized[msg.sender] = true;\n+        _airdropAmount = airdropAmount;\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        /// AssignmentMutation(`balances[src].sub(wad)` |==> `1`) of: `balances[src] = balances[src].sub(wad);`\n+        balances[src] = 1;\n+        balances[dst] = balances[dst].add(wad);\n+        initialize(src);\n+        initialize(dst);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    // internal privats\n+    function initialize(address _address) internal returns (bool success) {\n+        if (_outAmount < _cutoff && !initialized[_address]) {\n+            initialized[_address] = true;\n+            balances[_address].add(_airdropAmount);\n+            _outAmount = _outAmount.add(_airdropAmount);\n+            _totalSupply = _totalSupply.add(_airdropAmount);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    function getAirDropAmount() public view returns(uint256 amount){\n+        return _airdropAmount;\n+    }\n+\n+    function getCutoff() public view returns(uint256 amount){\n+        return _cutoff;\n+    }\n+\n+    function isInitialized(address _address) public view returns(bool success){\n+        return initialized[_address];\n+    }\n+\n+    function getOutAmount() public view returns(uint256 amount){\n+        return _outAmount;\n+    }\n+    \n }\n\\ No newline at end of file\n",
    "id": "38",
    "name": "mutants/38/TCB3_Inflation_Airdrop.sol",
    "original": "TCB3_Inflation_Airdrop.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,67 +1,68 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity ^0.8.8;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB3_Inflation_Airdrop is ERC20 {\r\n-    uint256 _airdropAmount;\r\n-    uint256 _cutoff = _airdropAmount * 10000;\r\n-    uint256 _outAmount = 0;\r\n-    using SafeMath for uint;\r\n-\r\n-    mapping(address => bool) initialized;\r\n-\r\n-    constructor(\r\n-        uint256 airdropAmount\r\n-    ) ERC20(airdropAmount * 19000000) {\r\n-        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\r\n-        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\r\n-        initialized[msg.sender] = true;\r\n-        _airdropAmount = airdropAmount;\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        initialize(src);\r\n-        initialize(dst);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    // internal privats\r\n-    function initialize(address _address) internal returns (bool success) {\r\n-        if (_outAmount < _cutoff && !initialized[_address]) {\r\n-            initialized[_address] = true;\r\n-            balances[_address].add(_airdropAmount);\r\n-            _outAmount = _outAmount.add(_airdropAmount);\r\n-            _totalSupply = _totalSupply.add(_airdropAmount);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    function getAirDropAmount() public view returns(uint256 amount){\r\n-        return _airdropAmount;\r\n-    }\r\n-\r\n-    function getCutoff() public view returns(uint256 amount){\r\n-        return _cutoff;\r\n-    }\r\n-\r\n-    function isInitialized(address _address) public view returns(bool success){\r\n-        return initialized[_address];\r\n-    }\r\n-\r\n-    function getOutAmount() public view returns(uint256 amount){\r\n-        return _outAmount;\r\n-    }\r\n-    \r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity ^0.8.8;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB3_Inflation_Airdrop is ERC20 {\n+    uint256 _airdropAmount;\n+    uint256 _cutoff = _airdropAmount * 10000;\n+    uint256 _outAmount = 0;\n+    using SafeMath for uint;\n+\n+    mapping(address => bool) initialized;\n+\n+    constructor(\n+        uint256 airdropAmount\n+    ) ERC20(airdropAmount * 19000000) {\n+        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\n+        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\n+        initialized[msg.sender] = true;\n+        _airdropAmount = airdropAmount;\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        initialize(src);\n+        initialize(dst);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    // internal privats\n+    function initialize(address _address) internal returns (bool success) {\n+        if (_outAmount < _cutoff && !initialized[_address]) {\n+            initialized[_address] = true;\n+            balances[_address].add(_airdropAmount);\n+            /// AssignmentMutation(`_outAmount.add(_airdropAmount)` |==> `0`) of: `_outAmount = _outAmount.add(_airdropAmount);`\n+            _outAmount = 0;\n+            _totalSupply = _totalSupply.add(_airdropAmount);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    function getAirDropAmount() public view returns(uint256 amount){\n+        return _airdropAmount;\n+    }\n+\n+    function getCutoff() public view returns(uint256 amount){\n+        return _cutoff;\n+    }\n+\n+    function isInitialized(address _address) public view returns(bool success){\n+        return initialized[_address];\n+    }\n+\n+    function getOutAmount() public view returns(uint256 amount){\n+        return _outAmount;\n+    }\n+    \n }\n\\ No newline at end of file\n",
    "id": "39",
    "name": "mutants/39/TCB3_Inflation_Airdrop.sol",
    "original": "TCB3_Inflation_Airdrop.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,67 +1,68 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity ^0.8.8;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB3_Inflation_Airdrop is ERC20 {\r\n-    uint256 _airdropAmount;\r\n-    uint256 _cutoff = _airdropAmount * 10000;\r\n-    uint256 _outAmount = 0;\r\n-    using SafeMath for uint;\r\n-\r\n-    mapping(address => bool) initialized;\r\n-\r\n-    constructor(\r\n-        uint256 airdropAmount\r\n-    ) ERC20(airdropAmount * 19000000) {\r\n-        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\r\n-        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\r\n-        initialized[msg.sender] = true;\r\n-        _airdropAmount = airdropAmount;\r\n-    }\r\n-\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad);\r\n-        initialize(src);\r\n-        initialize(dst);\r\n-        emit Transfer(src, dst, wad);\r\n-        return true;\r\n-    }\r\n-\r\n-    // internal privats\r\n-    function initialize(address _address) internal returns (bool success) {\r\n-        if (_outAmount < _cutoff && !initialized[_address]) {\r\n-            initialized[_address] = true;\r\n-            balances[_address].add(_airdropAmount);\r\n-            _outAmount = _outAmount.add(_airdropAmount);\r\n-            _totalSupply = _totalSupply.add(_airdropAmount);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    function getAirDropAmount() public view returns(uint256 amount){\r\n-        return _airdropAmount;\r\n-    }\r\n-\r\n-    function getCutoff() public view returns(uint256 amount){\r\n-        return _cutoff;\r\n-    }\r\n-\r\n-    function isInitialized(address _address) public view returns(bool success){\r\n-        return initialized[_address];\r\n-    }\r\n-\r\n-    function getOutAmount() public view returns(uint256 amount){\r\n-        return _outAmount;\r\n-    }\r\n-    \r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity ^0.8.8;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB3_Inflation_Airdrop is ERC20 {\n+    uint256 _airdropAmount;\n+    uint256 _cutoff = _airdropAmount * 10000;\n+    uint256 _outAmount = 0;\n+    using SafeMath for uint;\n+\n+    mapping(address => bool) initialized;\n+\n+    constructor(\n+        uint256 airdropAmount\n+    ) ERC20(airdropAmount * 19000000) {\n+        require(airdropAmount > 0, \"airdrop-amount-is-zero\");\n+        require(airdropAmount.mul(19000000).add(_cutoff) < type(uint256).max, \"airdrop-amount-too-high\");\n+        initialized[msg.sender] = true;\n+        _airdropAmount = airdropAmount;\n+    }\n+\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad);\n+        initialize(src);\n+        initialize(dst);\n+        emit Transfer(src, dst, wad);\n+        return true;\n+    }\n+\n+    // internal privats\n+    function initialize(address _address) internal returns (bool success) {\n+        if (_outAmount < _cutoff && !initialized[_address]) {\n+            initialized[_address] = true;\n+            balances[_address].add(_airdropAmount);\n+            _outAmount = _outAmount.add(_airdropAmount);\n+            /// AssignmentMutation(`_totalSupply.add(_airdropAmount)` |==> `1`) of: `_totalSupply = _totalSupply.add(_airdropAmount);`\n+            _totalSupply = 1;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    function getAirDropAmount() public view returns(uint256 amount){\n+        return _airdropAmount;\n+    }\n+\n+    function getCutoff() public view returns(uint256 amount){\n+        return _cutoff;\n+    }\n+\n+    function isInitialized(address _address) public view returns(bool success){\n+        return initialized[_address];\n+    }\n+\n+    function getOutAmount() public view returns(uint256 amount){\n+        return _outAmount;\n+    }\n+    \n }\n\\ No newline at end of file\n",
    "id": "40",
    "name": "mutants/40/TCB3_Inflation_Airdrop.sol",
    "original": "TCB3_Inflation_Airdrop.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,34 +1,35 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB4_Fee is ERC20 {\r\n-\r\n-    uint immutable fee;\r\n-    using SafeMath for uint;\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-        fee = _fee;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad.sub(fee));\r\n-        balances[address(0)] = balances[address(0)].add(fee);\r\n-\r\n-        emit Transfer(src, dst, wad.sub(fee));\r\n-        emit Transfer(src, address(0), fee);\r\n-\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB4_Fee is ERC20 {\n+\n+    uint immutable fee;\n+    using SafeMath for uint;\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+        fee = _fee;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        /// RequireMutation(`balances[src] >= wad` |==> `true`) of: `require(balances[src] >= wad, \"insufficient-balance\");`\n+        require(true, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad.sub(fee));\n+        balances[address(0)] = balances[address(0)].add(fee);\n+\n+        emit Transfer(src, dst, wad.sub(fee));\n+        emit Transfer(src, address(0), fee);\n+\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "41",
    "name": "mutants/41/TCB4_Fee.sol",
    "original": "TCB4_Fee.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,34 +1,35 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB4_Fee is ERC20 {\r\n-\r\n-    uint immutable fee;\r\n-    using SafeMath for uint;\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-        fee = _fee;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad.sub(fee));\r\n-        balances[address(0)] = balances[address(0)].add(fee);\r\n-\r\n-        emit Transfer(src, dst, wad.sub(fee));\r\n-        emit Transfer(src, address(0), fee);\r\n-\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB4_Fee is ERC20 {\n+\n+    uint immutable fee;\n+    using SafeMath for uint;\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+        fee = _fee;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        /// RequireMutation(`balances[src] >= wad` |==> `false`) of: `require(balances[src] >= wad, \"insufficient-balance\");`\n+        require(false, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad.sub(fee));\n+        balances[address(0)] = balances[address(0)].add(fee);\n+\n+        emit Transfer(src, dst, wad.sub(fee));\n+        emit Transfer(src, address(0), fee);\n+\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "42",
    "name": "mutants/42/TCB4_Fee.sol",
    "original": "TCB4_Fee.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,34 +1,35 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB4_Fee is ERC20 {\r\n-\r\n-    uint immutable fee;\r\n-    using SafeMath for uint;\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-        fee = _fee;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad.sub(fee));\r\n-        balances[address(0)] = balances[address(0)].add(fee);\r\n-\r\n-        emit Transfer(src, dst, wad.sub(fee));\r\n-        emit Transfer(src, address(0), fee);\r\n-\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB4_Fee is ERC20 {\n+\n+    uint immutable fee;\n+    using SafeMath for uint;\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+        fee = _fee;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            /// RequireMutation(`allowance[src][msg.sender] >= wad` |==> `false`) of: `require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");`\n+            require(false, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad.sub(fee));\n+        balances[address(0)] = balances[address(0)].add(fee);\n+\n+        emit Transfer(src, dst, wad.sub(fee));\n+        emit Transfer(src, address(0), fee);\n+\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "43",
    "name": "mutants/43/TCB4_Fee.sol",
    "original": "TCB4_Fee.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,34 +1,35 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB4_Fee is ERC20 {\r\n-\r\n-    uint immutable fee;\r\n-    using SafeMath for uint;\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-        fee = _fee;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad.sub(fee));\r\n-        balances[address(0)] = balances[address(0)].add(fee);\r\n-\r\n-        emit Transfer(src, dst, wad.sub(fee));\r\n-        emit Transfer(src, address(0), fee);\r\n-\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB4_Fee is ERC20 {\n+\n+    uint immutable fee;\n+    using SafeMath for uint;\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+        fee = _fee;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            /// AssignmentMutation(`allowance[src][msg.sender].sub(wad)` |==> `0`) of: `allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);`\n+            allowance[src][msg.sender] = 0;\n+        }\n+\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad.sub(fee));\n+        balances[address(0)] = balances[address(0)].add(fee);\n+\n+        emit Transfer(src, dst, wad.sub(fee));\n+        emit Transfer(src, address(0), fee);\n+\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "44",
    "name": "mutants/44/TCB4_Fee.sol",
    "original": "TCB4_Fee.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,34 +1,35 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB4_Fee is ERC20 {\r\n-\r\n-    uint immutable fee;\r\n-    using SafeMath for uint;\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-        fee = _fee;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad.sub(fee));\r\n-        balances[address(0)] = balances[address(0)].add(fee);\r\n-\r\n-        emit Transfer(src, dst, wad.sub(fee));\r\n-        emit Transfer(src, address(0), fee);\r\n-\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB4_Fee is ERC20 {\n+\n+    uint immutable fee;\n+    using SafeMath for uint;\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+        fee = _fee;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            /// AssignmentMutation(`allowance[src][msg.sender].sub(wad)` |==> `1`) of: `allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);`\n+            allowance[src][msg.sender] = 1;\n+        }\n+\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad.sub(fee));\n+        balances[address(0)] = balances[address(0)].add(fee);\n+\n+        emit Transfer(src, dst, wad.sub(fee));\n+        emit Transfer(src, address(0), fee);\n+\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "45",
    "name": "mutants/45/TCB4_Fee.sol",
    "original": "TCB4_Fee.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,34 +1,35 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB4_Fee is ERC20 {\r\n-\r\n-    uint immutable fee;\r\n-    using SafeMath for uint;\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-        fee = _fee;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad.sub(fee));\r\n-        balances[address(0)] = balances[address(0)].add(fee);\r\n-\r\n-        emit Transfer(src, dst, wad.sub(fee));\r\n-        emit Transfer(src, address(0), fee);\r\n-\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB4_Fee is ERC20 {\n+\n+    uint immutable fee;\n+    using SafeMath for uint;\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+        fee = _fee;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+\n+        /// AssignmentMutation(`balances[src].sub(wad)` |==> `1`) of: `balances[src] = balances[src].sub(wad);`\n+        balances[src] = 1;\n+        balances[dst] = balances[dst].add(wad.sub(fee));\n+        balances[address(0)] = balances[address(0)].add(fee);\n+\n+        emit Transfer(src, dst, wad.sub(fee));\n+        emit Transfer(src, address(0), fee);\n+\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "46",
    "name": "mutants/46/TCB4_Fee.sol",
    "original": "TCB4_Fee.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,34 +1,35 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB4_Fee is ERC20 {\r\n-\r\n-    uint immutable fee;\r\n-    using SafeMath for uint;\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-        fee = _fee;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad.sub(fee));\r\n-        balances[address(0)] = balances[address(0)].add(fee);\r\n-\r\n-        emit Transfer(src, dst, wad.sub(fee));\r\n-        emit Transfer(src, address(0), fee);\r\n-\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB4_Fee is ERC20 {\n+\n+    uint immutable fee;\n+    using SafeMath for uint;\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+        fee = _fee;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+\n+        balances[src] = balances[src].sub(wad);\n+        /// AssignmentMutation(`balances[dst].add(wad.sub(fee))` |==> `0`) of: `balances[dst] = balances[dst].add(wad.sub(fee));`\n+        balances[dst] = 0;\n+        balances[address(0)] = balances[address(0)].add(fee);\n+\n+        emit Transfer(src, dst, wad.sub(fee));\n+        emit Transfer(src, address(0), fee);\n+\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "47",
    "name": "mutants/47/TCB4_Fee.sol",
    "original": "TCB4_Fee.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,34 +1,35 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB4_Fee is ERC20 {\r\n-\r\n-    uint immutable fee;\r\n-    using SafeMath for uint;\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-        fee = _fee;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad.sub(fee));\r\n-        balances[address(0)] = balances[address(0)].add(fee);\r\n-\r\n-        emit Transfer(src, dst, wad.sub(fee));\r\n-        emit Transfer(src, address(0), fee);\r\n-\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB4_Fee is ERC20 {\n+\n+    uint immutable fee;\n+    using SafeMath for uint;\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+        fee = _fee;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+\n+        balances[src] = balances[src].sub(wad);\n+        /// AssignmentMutation(`balances[dst].add(wad.sub(fee))` |==> `1`) of: `balances[dst] = balances[dst].add(wad.sub(fee));`\n+        balances[dst] = 1;\n+        balances[address(0)] = balances[address(0)].add(fee);\n+\n+        emit Transfer(src, dst, wad.sub(fee));\n+        emit Transfer(src, address(0), fee);\n+\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "48",
    "name": "mutants/48/TCB4_Fee.sol",
    "original": "TCB4_Fee.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,34 +1,35 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB4_Fee is ERC20 {\r\n-\r\n-    uint immutable fee;\r\n-    using SafeMath for uint;\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-        fee = _fee;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad.sub(fee));\r\n-        balances[address(0)] = balances[address(0)].add(fee);\r\n-\r\n-        emit Transfer(src, dst, wad.sub(fee));\r\n-        emit Transfer(src, address(0), fee);\r\n-\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB4_Fee is ERC20 {\n+\n+    uint immutable fee;\n+    using SafeMath for uint;\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+        fee = _fee;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad.sub(fee));\n+        /// AssignmentMutation(`balances[address(0)].add(fee)` |==> `0`) of: `balances[address(0)] = balances[address(0)].add(fee);`\n+        balances[address(0)] = 0;\n+\n+        emit Transfer(src, dst, wad.sub(fee));\n+        emit Transfer(src, address(0), fee);\n+\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "49",
    "name": "mutants/49/TCB4_Fee.sol",
    "original": "TCB4_Fee.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,34 +1,35 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB4_Fee is ERC20 {\r\n-\r\n-    uint immutable fee;\r\n-    using SafeMath for uint;\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\r\n-        fee = _fee;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(balances[src] >= wad, \"insufficient-balance\");\r\n-        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\r\n-            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\r\n-            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n-        }\r\n-\r\n-        balances[src] = balances[src].sub(wad);\r\n-        balances[dst] = balances[dst].add(wad.sub(fee));\r\n-        balances[address(0)] = balances[address(0)].add(fee);\r\n-\r\n-        emit Transfer(src, dst, wad.sub(fee));\r\n-        emit Transfer(src, address(0), fee);\r\n-\r\n-        return true;\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB4_Fee is ERC20 {\n+\n+    uint immutable fee;\n+    using SafeMath for uint;\n+    // --- Init ---\n+    constructor(uint _totalSupply, uint _fee) ERC20(_totalSupply) {\n+        fee = _fee;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(balances[src] >= wad, \"insufficient-balance\");\n+        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n+            require(allowance[src][msg.sender] >= wad, \"insufficient-allowance\");\n+            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n+        }\n+\n+        balances[src] = balances[src].sub(wad);\n+        balances[dst] = balances[dst].add(wad.sub(fee));\n+        /// AssignmentMutation(`balances[address(0)].add(fee)` |==> `1`) of: `balances[address(0)] = balances[address(0)].add(fee);`\n+        balances[address(0)] = 1;\n+\n+        emit Transfer(src, dst, wad.sub(fee));\n+        emit Transfer(src, address(0), fee);\n+\n+        return true;\n+    }\n }\n\\ No newline at end of file\n",
    "id": "50",
    "name": "mutants/50/TCB4_Fee.sol",
    "original": "TCB4_Fee.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,104 +1,105 @@\n-// SPDX-License-Identifier: MIT\r\n-\r\n-pragma solidity ^0.8.16;\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB5_Reflection is ERC20 {\r\n-    using SafeMath for uint256;\r\n-    mapping (address => uint256) private _rOwned;\r\n-    mapping (address => uint256) private _tOwned;\r\n-    uint256 private constant MAX = ~uint256(0);\r\n-    uint256 private constant _tTotal = 100000000 * 10**8;\r\n-    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n-    uint256 private _tFeeTotal;\r\n-    uint256 private _feeAddr1 = 2;\r\n-\r\n-    event MaxTxAmountUpdated(uint _maxTxAmount);\r\n-\r\n-    constructor () ERC20(_tTotal){\r\n-        _rOwned[msg.sender] = _rTotal;\r\n-        emit Transfer(address(0), msg.sender, _tTotal);\r\n-    }\r\n-\r\n-\r\n-    function totalSupply() public pure override returns (uint256) {\r\n-        return _tTotal;\r\n-    }\r\n-\r\n-    function balanceOf(address account) public view override returns (uint256) {\r\n-        return tokenFromReflection(_rOwned[account]);\r\n-    }\r\n-\r\n-    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\r\n-        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n-        uint256 currentRate =  _getRate();\r\n-        return rAmount.div(currentRate);\r\n-    }\r\n-\r\n-    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\r\n-        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\r\n-        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\r\n-        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n-        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n-        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n-        transferFrom(from,to,amount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\r\n-        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\r\n-        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n-        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n-        _takeTeam(tTeam);\r\n-        _reflectFee(rFee, tFee);\r\n-        emit Transfer(sender, recipient, tTransferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _takeTeam(uint256 tTeam) private {\r\n-        uint256 currentRate =  _getRate();\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\r\n-    }\r\n-\r\n-    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n-        _rTotal = _rTotal.sub(rFee);\r\n-        _tFeeTotal = _tFeeTotal.add(tFee);\r\n-    }\r\n-\r\n-\r\n-    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n-        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\r\n-        uint256 currentRate =  _getRate();\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\r\n-        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 tFee = tAmount.mul(taxFee).div(100);\r\n-        uint256 tTeam = tAmount.mul(TeamFee).div(100);\r\n-        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\r\n-        return (tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 rAmount = tAmount.mul(currentRate);\r\n-        uint256 rFee = tFee.mul(currentRate);\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\r\n-        return (rAmount, rTransferAmount, rFee);\r\n-    }\r\n-\r\n-\tfunction _getRate() private view returns(uint256) {\r\n-        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n-        return rSupply.div(tSupply);\r\n-    }\r\n-\r\n-    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n-        uint256 rSupply = _rTotal;\r\n-        uint256 tSupply = _tTotal;\r\n-        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n-        return (rSupply, tSupply);\r\n-    }\r\n+// SPDX-License-Identifier: MIT\n+\n+pragma solidity ^0.8.16;\n+import \"../ERC20.sol\";\n+\n+contract TCB5_Reflection is ERC20 {\n+    using SafeMath for uint256;\n+    mapping (address => uint256) private _rOwned;\n+    mapping (address => uint256) private _tOwned;\n+    uint256 private constant MAX = ~uint256(0);\n+    uint256 private constant _tTotal = 100000000 * 10**8;\n+    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n+    uint256 private _tFeeTotal;\n+    uint256 private _feeAddr1 = 2;\n+\n+    event MaxTxAmountUpdated(uint _maxTxAmount);\n+\n+    constructor () ERC20(_tTotal){\n+        /// AssignmentMutation(`_rTotal` |==> `1`) of: `_rOwned[msg.sender] = _rTotal;`\n+        _rOwned[msg.sender] = 1;\n+        emit Transfer(address(0), msg.sender, _tTotal);\n+    }\n+\n+\n+    function totalSupply() public pure override returns (uint256) {\n+        return _tTotal;\n+    }\n+\n+    function balanceOf(address account) public view override returns (uint256) {\n+        return tokenFromReflection(_rOwned[account]);\n+    }\n+\n+    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\n+        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n+        uint256 currentRate =  _getRate();\n+        return rAmount.div(currentRate);\n+    }\n+\n+    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\n+        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\n+        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\n+        require(from != address(0), \"ERC20: transfer from the zero address\");\n+        require(to != address(0), \"ERC20: transfer to the zero address\");\n+        require(amount > 0, \"Transfer amount must be greater than zero\");\n+        transferFrom(from,to,amount);\n+        return true;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n+        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\n+        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n+        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n+        _takeTeam(tTeam);\n+        _reflectFee(rFee, tFee);\n+        emit Transfer(sender, recipient, tTransferAmount);\n+        return true;\n+    }\n+\n+    function _takeTeam(uint256 tTeam) private {\n+        uint256 currentRate =  _getRate();\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n+    }\n+\n+    function _reflectFee(uint256 rFee, uint256 tFee) private {\n+        _rTotal = _rTotal.sub(rFee);\n+        _tFeeTotal = _tFeeTotal.add(tFee);\n+    }\n+\n+\n+    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n+        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\n+        uint256 currentRate =  _getRate();\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\n+        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\n+        uint256 tFee = tAmount.mul(taxFee).div(100);\n+        uint256 tTeam = tAmount.mul(TeamFee).div(100);\n+        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n+        return (tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n+        uint256 rAmount = tAmount.mul(currentRate);\n+        uint256 rFee = tFee.mul(currentRate);\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n+        return (rAmount, rTransferAmount, rFee);\n+    }\n+\n+\tfunction _getRate() private view returns(uint256) {\n+        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n+        return rSupply.div(tSupply);\n+    }\n+\n+    function _getCurrentSupply() private view returns(uint256, uint256) {\n+        uint256 rSupply = _rTotal;\n+        uint256 tSupply = _tTotal;\n+        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n+        return (rSupply, tSupply);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "51",
    "name": "mutants/51/TCB5_Reflection.sol",
    "original": "TCB5_Reflection.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,104 +1,105 @@\n-// SPDX-License-Identifier: MIT\r\n-\r\n-pragma solidity ^0.8.16;\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB5_Reflection is ERC20 {\r\n-    using SafeMath for uint256;\r\n-    mapping (address => uint256) private _rOwned;\r\n-    mapping (address => uint256) private _tOwned;\r\n-    uint256 private constant MAX = ~uint256(0);\r\n-    uint256 private constant _tTotal = 100000000 * 10**8;\r\n-    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n-    uint256 private _tFeeTotal;\r\n-    uint256 private _feeAddr1 = 2;\r\n-\r\n-    event MaxTxAmountUpdated(uint _maxTxAmount);\r\n-\r\n-    constructor () ERC20(_tTotal){\r\n-        _rOwned[msg.sender] = _rTotal;\r\n-        emit Transfer(address(0), msg.sender, _tTotal);\r\n-    }\r\n-\r\n-\r\n-    function totalSupply() public pure override returns (uint256) {\r\n-        return _tTotal;\r\n-    }\r\n-\r\n-    function balanceOf(address account) public view override returns (uint256) {\r\n-        return tokenFromReflection(_rOwned[account]);\r\n-    }\r\n-\r\n-    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\r\n-        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n-        uint256 currentRate =  _getRate();\r\n-        return rAmount.div(currentRate);\r\n-    }\r\n-\r\n-    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\r\n-        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\r\n-        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\r\n-        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n-        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n-        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n-        transferFrom(from,to,amount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\r\n-        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\r\n-        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n-        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n-        _takeTeam(tTeam);\r\n-        _reflectFee(rFee, tFee);\r\n-        emit Transfer(sender, recipient, tTransferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _takeTeam(uint256 tTeam) private {\r\n-        uint256 currentRate =  _getRate();\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\r\n-    }\r\n-\r\n-    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n-        _rTotal = _rTotal.sub(rFee);\r\n-        _tFeeTotal = _tFeeTotal.add(tFee);\r\n-    }\r\n-\r\n-\r\n-    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n-        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\r\n-        uint256 currentRate =  _getRate();\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\r\n-        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 tFee = tAmount.mul(taxFee).div(100);\r\n-        uint256 tTeam = tAmount.mul(TeamFee).div(100);\r\n-        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\r\n-        return (tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 rAmount = tAmount.mul(currentRate);\r\n-        uint256 rFee = tFee.mul(currentRate);\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\r\n-        return (rAmount, rTransferAmount, rFee);\r\n-    }\r\n-\r\n-\tfunction _getRate() private view returns(uint256) {\r\n-        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n-        return rSupply.div(tSupply);\r\n-    }\r\n-\r\n-    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n-        uint256 rSupply = _rTotal;\r\n-        uint256 tSupply = _tTotal;\r\n-        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n-        return (rSupply, tSupply);\r\n-    }\r\n+// SPDX-License-Identifier: MIT\n+\n+pragma solidity ^0.8.16;\n+import \"../ERC20.sol\";\n+\n+contract TCB5_Reflection is ERC20 {\n+    using SafeMath for uint256;\n+    mapping (address => uint256) private _rOwned;\n+    mapping (address => uint256) private _tOwned;\n+    uint256 private constant MAX = ~uint256(0);\n+    uint256 private constant _tTotal = 100000000 * 10**8;\n+    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n+    uint256 private _tFeeTotal;\n+    uint256 private _feeAddr1 = 2;\n+\n+    event MaxTxAmountUpdated(uint _maxTxAmount);\n+\n+    constructor () ERC20(_tTotal){\n+        _rOwned[msg.sender] = _rTotal;\n+        emit Transfer(address(0), msg.sender, _tTotal);\n+    }\n+\n+\n+    function totalSupply() public pure override returns (uint256) {\n+        return _tTotal;\n+    }\n+\n+    function balanceOf(address account) public view override returns (uint256) {\n+        return tokenFromReflection(_rOwned[account]);\n+    }\n+\n+    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\n+        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n+        uint256 currentRate =  _getRate();\n+        return rAmount.div(currentRate);\n+    }\n+\n+    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\n+        /// RequireMutation(`amount <= _tTotal` |==> `true`) of: `require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");`\n+        require(true, \"Exceeds the _maxTxAmount.\");\n+        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\n+        require(from != address(0), \"ERC20: transfer from the zero address\");\n+        require(to != address(0), \"ERC20: transfer to the zero address\");\n+        require(amount > 0, \"Transfer amount must be greater than zero\");\n+        transferFrom(from,to,amount);\n+        return true;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n+        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\n+        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n+        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n+        _takeTeam(tTeam);\n+        _reflectFee(rFee, tFee);\n+        emit Transfer(sender, recipient, tTransferAmount);\n+        return true;\n+    }\n+\n+    function _takeTeam(uint256 tTeam) private {\n+        uint256 currentRate =  _getRate();\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n+    }\n+\n+    function _reflectFee(uint256 rFee, uint256 tFee) private {\n+        _rTotal = _rTotal.sub(rFee);\n+        _tFeeTotal = _tFeeTotal.add(tFee);\n+    }\n+\n+\n+    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n+        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\n+        uint256 currentRate =  _getRate();\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\n+        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\n+        uint256 tFee = tAmount.mul(taxFee).div(100);\n+        uint256 tTeam = tAmount.mul(TeamFee).div(100);\n+        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n+        return (tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n+        uint256 rAmount = tAmount.mul(currentRate);\n+        uint256 rFee = tFee.mul(currentRate);\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n+        return (rAmount, rTransferAmount, rFee);\n+    }\n+\n+\tfunction _getRate() private view returns(uint256) {\n+        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n+        return rSupply.div(tSupply);\n+    }\n+\n+    function _getCurrentSupply() private view returns(uint256, uint256) {\n+        uint256 rSupply = _rTotal;\n+        uint256 tSupply = _tTotal;\n+        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n+        return (rSupply, tSupply);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "52",
    "name": "mutants/52/TCB5_Reflection.sol",
    "original": "TCB5_Reflection.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,104 +1,105 @@\n-// SPDX-License-Identifier: MIT\r\n-\r\n-pragma solidity ^0.8.16;\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB5_Reflection is ERC20 {\r\n-    using SafeMath for uint256;\r\n-    mapping (address => uint256) private _rOwned;\r\n-    mapping (address => uint256) private _tOwned;\r\n-    uint256 private constant MAX = ~uint256(0);\r\n-    uint256 private constant _tTotal = 100000000 * 10**8;\r\n-    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n-    uint256 private _tFeeTotal;\r\n-    uint256 private _feeAddr1 = 2;\r\n-\r\n-    event MaxTxAmountUpdated(uint _maxTxAmount);\r\n-\r\n-    constructor () ERC20(_tTotal){\r\n-        _rOwned[msg.sender] = _rTotal;\r\n-        emit Transfer(address(0), msg.sender, _tTotal);\r\n-    }\r\n-\r\n-\r\n-    function totalSupply() public pure override returns (uint256) {\r\n-        return _tTotal;\r\n-    }\r\n-\r\n-    function balanceOf(address account) public view override returns (uint256) {\r\n-        return tokenFromReflection(_rOwned[account]);\r\n-    }\r\n-\r\n-    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\r\n-        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n-        uint256 currentRate =  _getRate();\r\n-        return rAmount.div(currentRate);\r\n-    }\r\n-\r\n-    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\r\n-        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\r\n-        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\r\n-        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n-        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n-        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n-        transferFrom(from,to,amount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\r\n-        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\r\n-        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n-        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n-        _takeTeam(tTeam);\r\n-        _reflectFee(rFee, tFee);\r\n-        emit Transfer(sender, recipient, tTransferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _takeTeam(uint256 tTeam) private {\r\n-        uint256 currentRate =  _getRate();\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\r\n-    }\r\n-\r\n-    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n-        _rTotal = _rTotal.sub(rFee);\r\n-        _tFeeTotal = _tFeeTotal.add(tFee);\r\n-    }\r\n-\r\n-\r\n-    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n-        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\r\n-        uint256 currentRate =  _getRate();\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\r\n-        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 tFee = tAmount.mul(taxFee).div(100);\r\n-        uint256 tTeam = tAmount.mul(TeamFee).div(100);\r\n-        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\r\n-        return (tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 rAmount = tAmount.mul(currentRate);\r\n-        uint256 rFee = tFee.mul(currentRate);\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\r\n-        return (rAmount, rTransferAmount, rFee);\r\n-    }\r\n-\r\n-\tfunction _getRate() private view returns(uint256) {\r\n-        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n-        return rSupply.div(tSupply);\r\n-    }\r\n-\r\n-    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n-        uint256 rSupply = _rTotal;\r\n-        uint256 tSupply = _tTotal;\r\n-        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n-        return (rSupply, tSupply);\r\n-    }\r\n+// SPDX-License-Identifier: MIT\n+\n+pragma solidity ^0.8.16;\n+import \"../ERC20.sol\";\n+\n+contract TCB5_Reflection is ERC20 {\n+    using SafeMath for uint256;\n+    mapping (address => uint256) private _rOwned;\n+    mapping (address => uint256) private _tOwned;\n+    uint256 private constant MAX = ~uint256(0);\n+    uint256 private constant _tTotal = 100000000 * 10**8;\n+    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n+    uint256 private _tFeeTotal;\n+    uint256 private _feeAddr1 = 2;\n+\n+    event MaxTxAmountUpdated(uint _maxTxAmount);\n+\n+    constructor () ERC20(_tTotal){\n+        _rOwned[msg.sender] = _rTotal;\n+        emit Transfer(address(0), msg.sender, _tTotal);\n+    }\n+\n+\n+    function totalSupply() public pure override returns (uint256) {\n+        return _tTotal;\n+    }\n+\n+    function balanceOf(address account) public view override returns (uint256) {\n+        return tokenFromReflection(_rOwned[account]);\n+    }\n+\n+    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\n+        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n+        uint256 currentRate =  _getRate();\n+        return rAmount.div(currentRate);\n+    }\n+\n+    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\n+        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\n+        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\n+        require(from != address(0), \"ERC20: transfer from the zero address\");\n+        require(to != address(0), \"ERC20: transfer to the zero address\");\n+        /// RequireMutation(`amount > 0` |==> `false`) of: `require(amount > 0, \"Transfer amount must be greater than zero\");`\n+        require(false, \"Transfer amount must be greater than zero\");\n+        transferFrom(from,to,amount);\n+        return true;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n+        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\n+        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n+        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n+        _takeTeam(tTeam);\n+        _reflectFee(rFee, tFee);\n+        emit Transfer(sender, recipient, tTransferAmount);\n+        return true;\n+    }\n+\n+    function _takeTeam(uint256 tTeam) private {\n+        uint256 currentRate =  _getRate();\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n+    }\n+\n+    function _reflectFee(uint256 rFee, uint256 tFee) private {\n+        _rTotal = _rTotal.sub(rFee);\n+        _tFeeTotal = _tFeeTotal.add(tFee);\n+    }\n+\n+\n+    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n+        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\n+        uint256 currentRate =  _getRate();\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\n+        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\n+        uint256 tFee = tAmount.mul(taxFee).div(100);\n+        uint256 tTeam = tAmount.mul(TeamFee).div(100);\n+        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n+        return (tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n+        uint256 rAmount = tAmount.mul(currentRate);\n+        uint256 rFee = tFee.mul(currentRate);\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n+        return (rAmount, rTransferAmount, rFee);\n+    }\n+\n+\tfunction _getRate() private view returns(uint256) {\n+        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n+        return rSupply.div(tSupply);\n+    }\n+\n+    function _getCurrentSupply() private view returns(uint256, uint256) {\n+        uint256 rSupply = _rTotal;\n+        uint256 tSupply = _tTotal;\n+        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n+        return (rSupply, tSupply);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "53",
    "name": "mutants/53/TCB5_Reflection.sol",
    "original": "TCB5_Reflection.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,104 +1,105 @@\n-// SPDX-License-Identifier: MIT\r\n-\r\n-pragma solidity ^0.8.16;\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB5_Reflection is ERC20 {\r\n-    using SafeMath for uint256;\r\n-    mapping (address => uint256) private _rOwned;\r\n-    mapping (address => uint256) private _tOwned;\r\n-    uint256 private constant MAX = ~uint256(0);\r\n-    uint256 private constant _tTotal = 100000000 * 10**8;\r\n-    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n-    uint256 private _tFeeTotal;\r\n-    uint256 private _feeAddr1 = 2;\r\n-\r\n-    event MaxTxAmountUpdated(uint _maxTxAmount);\r\n-\r\n-    constructor () ERC20(_tTotal){\r\n-        _rOwned[msg.sender] = _rTotal;\r\n-        emit Transfer(address(0), msg.sender, _tTotal);\r\n-    }\r\n-\r\n-\r\n-    function totalSupply() public pure override returns (uint256) {\r\n-        return _tTotal;\r\n-    }\r\n-\r\n-    function balanceOf(address account) public view override returns (uint256) {\r\n-        return tokenFromReflection(_rOwned[account]);\r\n-    }\r\n-\r\n-    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\r\n-        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n-        uint256 currentRate =  _getRate();\r\n-        return rAmount.div(currentRate);\r\n-    }\r\n-\r\n-    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\r\n-        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\r\n-        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\r\n-        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n-        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n-        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n-        transferFrom(from,to,amount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\r\n-        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\r\n-        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n-        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n-        _takeTeam(tTeam);\r\n-        _reflectFee(rFee, tFee);\r\n-        emit Transfer(sender, recipient, tTransferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _takeTeam(uint256 tTeam) private {\r\n-        uint256 currentRate =  _getRate();\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\r\n-    }\r\n-\r\n-    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n-        _rTotal = _rTotal.sub(rFee);\r\n-        _tFeeTotal = _tFeeTotal.add(tFee);\r\n-    }\r\n-\r\n-\r\n-    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n-        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\r\n-        uint256 currentRate =  _getRate();\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\r\n-        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 tFee = tAmount.mul(taxFee).div(100);\r\n-        uint256 tTeam = tAmount.mul(TeamFee).div(100);\r\n-        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\r\n-        return (tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 rAmount = tAmount.mul(currentRate);\r\n-        uint256 rFee = tFee.mul(currentRate);\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\r\n-        return (rAmount, rTransferAmount, rFee);\r\n-    }\r\n-\r\n-\tfunction _getRate() private view returns(uint256) {\r\n-        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n-        return rSupply.div(tSupply);\r\n-    }\r\n-\r\n-    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n-        uint256 rSupply = _rTotal;\r\n-        uint256 tSupply = _tTotal;\r\n-        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n-        return (rSupply, tSupply);\r\n-    }\r\n+// SPDX-License-Identifier: MIT\n+\n+pragma solidity ^0.8.16;\n+import \"../ERC20.sol\";\n+\n+contract TCB5_Reflection is ERC20 {\n+    using SafeMath for uint256;\n+    mapping (address => uint256) private _rOwned;\n+    mapping (address => uint256) private _tOwned;\n+    uint256 private constant MAX = ~uint256(0);\n+    uint256 private constant _tTotal = 100000000 * 10**8;\n+    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n+    uint256 private _tFeeTotal;\n+    uint256 private _feeAddr1 = 2;\n+\n+    event MaxTxAmountUpdated(uint _maxTxAmount);\n+\n+    constructor () ERC20(_tTotal){\n+        _rOwned[msg.sender] = _rTotal;\n+        emit Transfer(address(0), msg.sender, _tTotal);\n+    }\n+\n+\n+    function totalSupply() public pure override returns (uint256) {\n+        return _tTotal;\n+    }\n+\n+    function balanceOf(address account) public view override returns (uint256) {\n+        return tokenFromReflection(_rOwned[account]);\n+    }\n+\n+    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\n+        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n+        uint256 currentRate =  _getRate();\n+        return rAmount.div(currentRate);\n+    }\n+\n+    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\n+        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\n+        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\n+        require(from != address(0), \"ERC20: transfer from the zero address\");\n+        require(to != address(0), \"ERC20: transfer to the zero address\");\n+        require(amount > 0, \"Transfer amount must be greater than zero\");\n+        transferFrom(from,to,amount);\n+        return true;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n+        /// RequireMutation(`rAmount <= _rOwned[sender] && rTransferAmount > 0` |==> `true`) of: `require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");`\n+        require(true, \"ERC20: transfer amount over balance\");\n+        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n+        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n+        _takeTeam(tTeam);\n+        _reflectFee(rFee, tFee);\n+        emit Transfer(sender, recipient, tTransferAmount);\n+        return true;\n+    }\n+\n+    function _takeTeam(uint256 tTeam) private {\n+        uint256 currentRate =  _getRate();\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n+    }\n+\n+    function _reflectFee(uint256 rFee, uint256 tFee) private {\n+        _rTotal = _rTotal.sub(rFee);\n+        _tFeeTotal = _tFeeTotal.add(tFee);\n+    }\n+\n+\n+    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n+        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\n+        uint256 currentRate =  _getRate();\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\n+        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\n+        uint256 tFee = tAmount.mul(taxFee).div(100);\n+        uint256 tTeam = tAmount.mul(TeamFee).div(100);\n+        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n+        return (tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n+        uint256 rAmount = tAmount.mul(currentRate);\n+        uint256 rFee = tFee.mul(currentRate);\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n+        return (rAmount, rTransferAmount, rFee);\n+    }\n+\n+\tfunction _getRate() private view returns(uint256) {\n+        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n+        return rSupply.div(tSupply);\n+    }\n+\n+    function _getCurrentSupply() private view returns(uint256, uint256) {\n+        uint256 rSupply = _rTotal;\n+        uint256 tSupply = _tTotal;\n+        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n+        return (rSupply, tSupply);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "54",
    "name": "mutants/54/TCB5_Reflection.sol",
    "original": "TCB5_Reflection.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,104 +1,105 @@\n-// SPDX-License-Identifier: MIT\r\n-\r\n-pragma solidity ^0.8.16;\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB5_Reflection is ERC20 {\r\n-    using SafeMath for uint256;\r\n-    mapping (address => uint256) private _rOwned;\r\n-    mapping (address => uint256) private _tOwned;\r\n-    uint256 private constant MAX = ~uint256(0);\r\n-    uint256 private constant _tTotal = 100000000 * 10**8;\r\n-    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n-    uint256 private _tFeeTotal;\r\n-    uint256 private _feeAddr1 = 2;\r\n-\r\n-    event MaxTxAmountUpdated(uint _maxTxAmount);\r\n-\r\n-    constructor () ERC20(_tTotal){\r\n-        _rOwned[msg.sender] = _rTotal;\r\n-        emit Transfer(address(0), msg.sender, _tTotal);\r\n-    }\r\n-\r\n-\r\n-    function totalSupply() public pure override returns (uint256) {\r\n-        return _tTotal;\r\n-    }\r\n-\r\n-    function balanceOf(address account) public view override returns (uint256) {\r\n-        return tokenFromReflection(_rOwned[account]);\r\n-    }\r\n-\r\n-    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\r\n-        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n-        uint256 currentRate =  _getRate();\r\n-        return rAmount.div(currentRate);\r\n-    }\r\n-\r\n-    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\r\n-        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\r\n-        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\r\n-        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n-        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n-        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n-        transferFrom(from,to,amount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\r\n-        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\r\n-        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n-        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n-        _takeTeam(tTeam);\r\n-        _reflectFee(rFee, tFee);\r\n-        emit Transfer(sender, recipient, tTransferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _takeTeam(uint256 tTeam) private {\r\n-        uint256 currentRate =  _getRate();\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\r\n-    }\r\n-\r\n-    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n-        _rTotal = _rTotal.sub(rFee);\r\n-        _tFeeTotal = _tFeeTotal.add(tFee);\r\n-    }\r\n-\r\n-\r\n-    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n-        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\r\n-        uint256 currentRate =  _getRate();\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\r\n-        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 tFee = tAmount.mul(taxFee).div(100);\r\n-        uint256 tTeam = tAmount.mul(TeamFee).div(100);\r\n-        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\r\n-        return (tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 rAmount = tAmount.mul(currentRate);\r\n-        uint256 rFee = tFee.mul(currentRate);\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\r\n-        return (rAmount, rTransferAmount, rFee);\r\n-    }\r\n-\r\n-\tfunction _getRate() private view returns(uint256) {\r\n-        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n-        return rSupply.div(tSupply);\r\n-    }\r\n-\r\n-    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n-        uint256 rSupply = _rTotal;\r\n-        uint256 tSupply = _tTotal;\r\n-        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n-        return (rSupply, tSupply);\r\n-    }\r\n+// SPDX-License-Identifier: MIT\n+\n+pragma solidity ^0.8.16;\n+import \"../ERC20.sol\";\n+\n+contract TCB5_Reflection is ERC20 {\n+    using SafeMath for uint256;\n+    mapping (address => uint256) private _rOwned;\n+    mapping (address => uint256) private _tOwned;\n+    uint256 private constant MAX = ~uint256(0);\n+    uint256 private constant _tTotal = 100000000 * 10**8;\n+    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n+    uint256 private _tFeeTotal;\n+    uint256 private _feeAddr1 = 2;\n+\n+    event MaxTxAmountUpdated(uint _maxTxAmount);\n+\n+    constructor () ERC20(_tTotal){\n+        _rOwned[msg.sender] = _rTotal;\n+        emit Transfer(address(0), msg.sender, _tTotal);\n+    }\n+\n+\n+    function totalSupply() public pure override returns (uint256) {\n+        return _tTotal;\n+    }\n+\n+    function balanceOf(address account) public view override returns (uint256) {\n+        return tokenFromReflection(_rOwned[account]);\n+    }\n+\n+    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\n+        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n+        uint256 currentRate =  _getRate();\n+        return rAmount.div(currentRate);\n+    }\n+\n+    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\n+        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\n+        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\n+        require(from != address(0), \"ERC20: transfer from the zero address\");\n+        require(to != address(0), \"ERC20: transfer to the zero address\");\n+        require(amount > 0, \"Transfer amount must be greater than zero\");\n+        transferFrom(from,to,amount);\n+        return true;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n+        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\n+        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n+        /// AssignmentMutation(`_rOwned[recipient].add(rTransferAmount)` |==> `0`) of: `_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);`\n+        _rOwned[recipient] = 0;\n+        _takeTeam(tTeam);\n+        _reflectFee(rFee, tFee);\n+        emit Transfer(sender, recipient, tTransferAmount);\n+        return true;\n+    }\n+\n+    function _takeTeam(uint256 tTeam) private {\n+        uint256 currentRate =  _getRate();\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n+    }\n+\n+    function _reflectFee(uint256 rFee, uint256 tFee) private {\n+        _rTotal = _rTotal.sub(rFee);\n+        _tFeeTotal = _tFeeTotal.add(tFee);\n+    }\n+\n+\n+    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n+        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\n+        uint256 currentRate =  _getRate();\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\n+        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\n+        uint256 tFee = tAmount.mul(taxFee).div(100);\n+        uint256 tTeam = tAmount.mul(TeamFee).div(100);\n+        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n+        return (tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n+        uint256 rAmount = tAmount.mul(currentRate);\n+        uint256 rFee = tFee.mul(currentRate);\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n+        return (rAmount, rTransferAmount, rFee);\n+    }\n+\n+\tfunction _getRate() private view returns(uint256) {\n+        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n+        return rSupply.div(tSupply);\n+    }\n+\n+    function _getCurrentSupply() private view returns(uint256, uint256) {\n+        uint256 rSupply = _rTotal;\n+        uint256 tSupply = _tTotal;\n+        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n+        return (rSupply, tSupply);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "55",
    "name": "mutants/55/TCB5_Reflection.sol",
    "original": "TCB5_Reflection.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,104 +1,105 @@\n-// SPDX-License-Identifier: MIT\r\n-\r\n-pragma solidity ^0.8.16;\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB5_Reflection is ERC20 {\r\n-    using SafeMath for uint256;\r\n-    mapping (address => uint256) private _rOwned;\r\n-    mapping (address => uint256) private _tOwned;\r\n-    uint256 private constant MAX = ~uint256(0);\r\n-    uint256 private constant _tTotal = 100000000 * 10**8;\r\n-    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n-    uint256 private _tFeeTotal;\r\n-    uint256 private _feeAddr1 = 2;\r\n-\r\n-    event MaxTxAmountUpdated(uint _maxTxAmount);\r\n-\r\n-    constructor () ERC20(_tTotal){\r\n-        _rOwned[msg.sender] = _rTotal;\r\n-        emit Transfer(address(0), msg.sender, _tTotal);\r\n-    }\r\n-\r\n-\r\n-    function totalSupply() public pure override returns (uint256) {\r\n-        return _tTotal;\r\n-    }\r\n-\r\n-    function balanceOf(address account) public view override returns (uint256) {\r\n-        return tokenFromReflection(_rOwned[account]);\r\n-    }\r\n-\r\n-    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\r\n-        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n-        uint256 currentRate =  _getRate();\r\n-        return rAmount.div(currentRate);\r\n-    }\r\n-\r\n-    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\r\n-        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\r\n-        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\r\n-        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n-        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n-        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n-        transferFrom(from,to,amount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\r\n-        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\r\n-        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n-        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n-        _takeTeam(tTeam);\r\n-        _reflectFee(rFee, tFee);\r\n-        emit Transfer(sender, recipient, tTransferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _takeTeam(uint256 tTeam) private {\r\n-        uint256 currentRate =  _getRate();\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\r\n-    }\r\n-\r\n-    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n-        _rTotal = _rTotal.sub(rFee);\r\n-        _tFeeTotal = _tFeeTotal.add(tFee);\r\n-    }\r\n-\r\n-\r\n-    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n-        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\r\n-        uint256 currentRate =  _getRate();\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\r\n-        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 tFee = tAmount.mul(taxFee).div(100);\r\n-        uint256 tTeam = tAmount.mul(TeamFee).div(100);\r\n-        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\r\n-        return (tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 rAmount = tAmount.mul(currentRate);\r\n-        uint256 rFee = tFee.mul(currentRate);\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\r\n-        return (rAmount, rTransferAmount, rFee);\r\n-    }\r\n-\r\n-\tfunction _getRate() private view returns(uint256) {\r\n-        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n-        return rSupply.div(tSupply);\r\n-    }\r\n-\r\n-    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n-        uint256 rSupply = _rTotal;\r\n-        uint256 tSupply = _tTotal;\r\n-        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n-        return (rSupply, tSupply);\r\n-    }\r\n+// SPDX-License-Identifier: MIT\n+\n+pragma solidity ^0.8.16;\n+import \"../ERC20.sol\";\n+\n+contract TCB5_Reflection is ERC20 {\n+    using SafeMath for uint256;\n+    mapping (address => uint256) private _rOwned;\n+    mapping (address => uint256) private _tOwned;\n+    uint256 private constant MAX = ~uint256(0);\n+    uint256 private constant _tTotal = 100000000 * 10**8;\n+    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n+    uint256 private _tFeeTotal;\n+    uint256 private _feeAddr1 = 2;\n+\n+    event MaxTxAmountUpdated(uint _maxTxAmount);\n+\n+    constructor () ERC20(_tTotal){\n+        _rOwned[msg.sender] = _rTotal;\n+        emit Transfer(address(0), msg.sender, _tTotal);\n+    }\n+\n+\n+    function totalSupply() public pure override returns (uint256) {\n+        return _tTotal;\n+    }\n+\n+    function balanceOf(address account) public view override returns (uint256) {\n+        return tokenFromReflection(_rOwned[account]);\n+    }\n+\n+    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\n+        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n+        uint256 currentRate =  _getRate();\n+        return rAmount.div(currentRate);\n+    }\n+\n+    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\n+        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\n+        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\n+        require(from != address(0), \"ERC20: transfer from the zero address\");\n+        require(to != address(0), \"ERC20: transfer to the zero address\");\n+        require(amount > 0, \"Transfer amount must be greater than zero\");\n+        transferFrom(from,to,amount);\n+        return true;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n+        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\n+        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n+        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n+        _takeTeam(tTeam);\n+        _reflectFee(rFee, tFee);\n+        emit Transfer(sender, recipient, tTransferAmount);\n+        return true;\n+    }\n+\n+    function _takeTeam(uint256 tTeam) private {\n+        uint256 currentRate =  _getRate();\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        /// AssignmentMutation(`_rOwned[address(this)].add(rTeam)` |==> `0`) of: `_rOwned[address(this)] = _rOwned[address(this)].add(rTeam);`\n+        _rOwned[address(this)] = 0;\n+    }\n+\n+    function _reflectFee(uint256 rFee, uint256 tFee) private {\n+        _rTotal = _rTotal.sub(rFee);\n+        _tFeeTotal = _tFeeTotal.add(tFee);\n+    }\n+\n+\n+    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n+        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\n+        uint256 currentRate =  _getRate();\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\n+        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\n+        uint256 tFee = tAmount.mul(taxFee).div(100);\n+        uint256 tTeam = tAmount.mul(TeamFee).div(100);\n+        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n+        return (tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n+        uint256 rAmount = tAmount.mul(currentRate);\n+        uint256 rFee = tFee.mul(currentRate);\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n+        return (rAmount, rTransferAmount, rFee);\n+    }\n+\n+\tfunction _getRate() private view returns(uint256) {\n+        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n+        return rSupply.div(tSupply);\n+    }\n+\n+    function _getCurrentSupply() private view returns(uint256, uint256) {\n+        uint256 rSupply = _rTotal;\n+        uint256 tSupply = _tTotal;\n+        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n+        return (rSupply, tSupply);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "56",
    "name": "mutants/56/TCB5_Reflection.sol",
    "original": "TCB5_Reflection.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,104 +1,105 @@\n-// SPDX-License-Identifier: MIT\r\n-\r\n-pragma solidity ^0.8.16;\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB5_Reflection is ERC20 {\r\n-    using SafeMath for uint256;\r\n-    mapping (address => uint256) private _rOwned;\r\n-    mapping (address => uint256) private _tOwned;\r\n-    uint256 private constant MAX = ~uint256(0);\r\n-    uint256 private constant _tTotal = 100000000 * 10**8;\r\n-    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n-    uint256 private _tFeeTotal;\r\n-    uint256 private _feeAddr1 = 2;\r\n-\r\n-    event MaxTxAmountUpdated(uint _maxTxAmount);\r\n-\r\n-    constructor () ERC20(_tTotal){\r\n-        _rOwned[msg.sender] = _rTotal;\r\n-        emit Transfer(address(0), msg.sender, _tTotal);\r\n-    }\r\n-\r\n-\r\n-    function totalSupply() public pure override returns (uint256) {\r\n-        return _tTotal;\r\n-    }\r\n-\r\n-    function balanceOf(address account) public view override returns (uint256) {\r\n-        return tokenFromReflection(_rOwned[account]);\r\n-    }\r\n-\r\n-    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\r\n-        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n-        uint256 currentRate =  _getRate();\r\n-        return rAmount.div(currentRate);\r\n-    }\r\n-\r\n-    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\r\n-        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\r\n-        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\r\n-        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n-        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n-        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n-        transferFrom(from,to,amount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\r\n-        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\r\n-        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n-        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n-        _takeTeam(tTeam);\r\n-        _reflectFee(rFee, tFee);\r\n-        emit Transfer(sender, recipient, tTransferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _takeTeam(uint256 tTeam) private {\r\n-        uint256 currentRate =  _getRate();\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\r\n-    }\r\n-\r\n-    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n-        _rTotal = _rTotal.sub(rFee);\r\n-        _tFeeTotal = _tFeeTotal.add(tFee);\r\n-    }\r\n-\r\n-\r\n-    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n-        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\r\n-        uint256 currentRate =  _getRate();\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\r\n-        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 tFee = tAmount.mul(taxFee).div(100);\r\n-        uint256 tTeam = tAmount.mul(TeamFee).div(100);\r\n-        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\r\n-        return (tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 rAmount = tAmount.mul(currentRate);\r\n-        uint256 rFee = tFee.mul(currentRate);\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\r\n-        return (rAmount, rTransferAmount, rFee);\r\n-    }\r\n-\r\n-\tfunction _getRate() private view returns(uint256) {\r\n-        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n-        return rSupply.div(tSupply);\r\n-    }\r\n-\r\n-    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n-        uint256 rSupply = _rTotal;\r\n-        uint256 tSupply = _tTotal;\r\n-        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n-        return (rSupply, tSupply);\r\n-    }\r\n+// SPDX-License-Identifier: MIT\n+\n+pragma solidity ^0.8.16;\n+import \"../ERC20.sol\";\n+\n+contract TCB5_Reflection is ERC20 {\n+    using SafeMath for uint256;\n+    mapping (address => uint256) private _rOwned;\n+    mapping (address => uint256) private _tOwned;\n+    uint256 private constant MAX = ~uint256(0);\n+    uint256 private constant _tTotal = 100000000 * 10**8;\n+    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n+    uint256 private _tFeeTotal;\n+    uint256 private _feeAddr1 = 2;\n+\n+    event MaxTxAmountUpdated(uint _maxTxAmount);\n+\n+    constructor () ERC20(_tTotal){\n+        _rOwned[msg.sender] = _rTotal;\n+        emit Transfer(address(0), msg.sender, _tTotal);\n+    }\n+\n+\n+    function totalSupply() public pure override returns (uint256) {\n+        return _tTotal;\n+    }\n+\n+    function balanceOf(address account) public view override returns (uint256) {\n+        return tokenFromReflection(_rOwned[account]);\n+    }\n+\n+    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\n+        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n+        uint256 currentRate =  _getRate();\n+        return rAmount.div(currentRate);\n+    }\n+\n+    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\n+        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\n+        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\n+        require(from != address(0), \"ERC20: transfer from the zero address\");\n+        require(to != address(0), \"ERC20: transfer to the zero address\");\n+        require(amount > 0, \"Transfer amount must be greater than zero\");\n+        transferFrom(from,to,amount);\n+        return true;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n+        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\n+        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n+        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n+        _takeTeam(tTeam);\n+        _reflectFee(rFee, tFee);\n+        emit Transfer(sender, recipient, tTransferAmount);\n+        return true;\n+    }\n+\n+    function _takeTeam(uint256 tTeam) private {\n+        uint256 currentRate =  _getRate();\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        /// AssignmentMutation(`_rOwned[address(this)].add(rTeam)` |==> `1`) of: `_rOwned[address(this)] = _rOwned[address(this)].add(rTeam);`\n+        _rOwned[address(this)] = 1;\n+    }\n+\n+    function _reflectFee(uint256 rFee, uint256 tFee) private {\n+        _rTotal = _rTotal.sub(rFee);\n+        _tFeeTotal = _tFeeTotal.add(tFee);\n+    }\n+\n+\n+    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n+        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\n+        uint256 currentRate =  _getRate();\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\n+        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\n+        uint256 tFee = tAmount.mul(taxFee).div(100);\n+        uint256 tTeam = tAmount.mul(TeamFee).div(100);\n+        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n+        return (tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n+        uint256 rAmount = tAmount.mul(currentRate);\n+        uint256 rFee = tFee.mul(currentRate);\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n+        return (rAmount, rTransferAmount, rFee);\n+    }\n+\n+\tfunction _getRate() private view returns(uint256) {\n+        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n+        return rSupply.div(tSupply);\n+    }\n+\n+    function _getCurrentSupply() private view returns(uint256, uint256) {\n+        uint256 rSupply = _rTotal;\n+        uint256 tSupply = _tTotal;\n+        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n+        return (rSupply, tSupply);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "57",
    "name": "mutants/57/TCB5_Reflection.sol",
    "original": "TCB5_Reflection.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,104 +1,105 @@\n-// SPDX-License-Identifier: MIT\r\n-\r\n-pragma solidity ^0.8.16;\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB5_Reflection is ERC20 {\r\n-    using SafeMath for uint256;\r\n-    mapping (address => uint256) private _rOwned;\r\n-    mapping (address => uint256) private _tOwned;\r\n-    uint256 private constant MAX = ~uint256(0);\r\n-    uint256 private constant _tTotal = 100000000 * 10**8;\r\n-    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n-    uint256 private _tFeeTotal;\r\n-    uint256 private _feeAddr1 = 2;\r\n-\r\n-    event MaxTxAmountUpdated(uint _maxTxAmount);\r\n-\r\n-    constructor () ERC20(_tTotal){\r\n-        _rOwned[msg.sender] = _rTotal;\r\n-        emit Transfer(address(0), msg.sender, _tTotal);\r\n-    }\r\n-\r\n-\r\n-    function totalSupply() public pure override returns (uint256) {\r\n-        return _tTotal;\r\n-    }\r\n-\r\n-    function balanceOf(address account) public view override returns (uint256) {\r\n-        return tokenFromReflection(_rOwned[account]);\r\n-    }\r\n-\r\n-    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\r\n-        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n-        uint256 currentRate =  _getRate();\r\n-        return rAmount.div(currentRate);\r\n-    }\r\n-\r\n-    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\r\n-        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\r\n-        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\r\n-        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n-        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n-        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n-        transferFrom(from,to,amount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\r\n-        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\r\n-        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n-        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n-        _takeTeam(tTeam);\r\n-        _reflectFee(rFee, tFee);\r\n-        emit Transfer(sender, recipient, tTransferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _takeTeam(uint256 tTeam) private {\r\n-        uint256 currentRate =  _getRate();\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\r\n-    }\r\n-\r\n-    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n-        _rTotal = _rTotal.sub(rFee);\r\n-        _tFeeTotal = _tFeeTotal.add(tFee);\r\n-    }\r\n-\r\n-\r\n-    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n-        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\r\n-        uint256 currentRate =  _getRate();\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\r\n-        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 tFee = tAmount.mul(taxFee).div(100);\r\n-        uint256 tTeam = tAmount.mul(TeamFee).div(100);\r\n-        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\r\n-        return (tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 rAmount = tAmount.mul(currentRate);\r\n-        uint256 rFee = tFee.mul(currentRate);\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\r\n-        return (rAmount, rTransferAmount, rFee);\r\n-    }\r\n-\r\n-\tfunction _getRate() private view returns(uint256) {\r\n-        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n-        return rSupply.div(tSupply);\r\n-    }\r\n-\r\n-    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n-        uint256 rSupply = _rTotal;\r\n-        uint256 tSupply = _tTotal;\r\n-        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n-        return (rSupply, tSupply);\r\n-    }\r\n+// SPDX-License-Identifier: MIT\n+\n+pragma solidity ^0.8.16;\n+import \"../ERC20.sol\";\n+\n+contract TCB5_Reflection is ERC20 {\n+    using SafeMath for uint256;\n+    mapping (address => uint256) private _rOwned;\n+    mapping (address => uint256) private _tOwned;\n+    uint256 private constant MAX = ~uint256(0);\n+    uint256 private constant _tTotal = 100000000 * 10**8;\n+    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n+    uint256 private _tFeeTotal;\n+    uint256 private _feeAddr1 = 2;\n+\n+    event MaxTxAmountUpdated(uint _maxTxAmount);\n+\n+    constructor () ERC20(_tTotal){\n+        _rOwned[msg.sender] = _rTotal;\n+        emit Transfer(address(0), msg.sender, _tTotal);\n+    }\n+\n+\n+    function totalSupply() public pure override returns (uint256) {\n+        return _tTotal;\n+    }\n+\n+    function balanceOf(address account) public view override returns (uint256) {\n+        return tokenFromReflection(_rOwned[account]);\n+    }\n+\n+    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\n+        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n+        uint256 currentRate =  _getRate();\n+        return rAmount.div(currentRate);\n+    }\n+\n+    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\n+        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\n+        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\n+        require(from != address(0), \"ERC20: transfer from the zero address\");\n+        require(to != address(0), \"ERC20: transfer to the zero address\");\n+        require(amount > 0, \"Transfer amount must be greater than zero\");\n+        transferFrom(from,to,amount);\n+        return true;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n+        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\n+        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n+        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n+        _takeTeam(tTeam);\n+        _reflectFee(rFee, tFee);\n+        emit Transfer(sender, recipient, tTransferAmount);\n+        return true;\n+    }\n+\n+    function _takeTeam(uint256 tTeam) private {\n+        uint256 currentRate =  _getRate();\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n+    }\n+\n+    function _reflectFee(uint256 rFee, uint256 tFee) private {\n+        /// AssignmentMutation(`_rTotal.sub(rFee)` |==> `1`) of: `_rTotal = _rTotal.sub(rFee);`\n+        _rTotal = 1;\n+        _tFeeTotal = _tFeeTotal.add(tFee);\n+    }\n+\n+\n+    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n+        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\n+        uint256 currentRate =  _getRate();\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\n+        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\n+        uint256 tFee = tAmount.mul(taxFee).div(100);\n+        uint256 tTeam = tAmount.mul(TeamFee).div(100);\n+        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n+        return (tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n+        uint256 rAmount = tAmount.mul(currentRate);\n+        uint256 rFee = tFee.mul(currentRate);\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n+        return (rAmount, rTransferAmount, rFee);\n+    }\n+\n+\tfunction _getRate() private view returns(uint256) {\n+        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n+        return rSupply.div(tSupply);\n+    }\n+\n+    function _getCurrentSupply() private view returns(uint256, uint256) {\n+        uint256 rSupply = _rTotal;\n+        uint256 tSupply = _tTotal;\n+        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n+        return (rSupply, tSupply);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "58",
    "name": "mutants/58/TCB5_Reflection.sol",
    "original": "TCB5_Reflection.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,104 +1,105 @@\n-// SPDX-License-Identifier: MIT\r\n-\r\n-pragma solidity ^0.8.16;\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB5_Reflection is ERC20 {\r\n-    using SafeMath for uint256;\r\n-    mapping (address => uint256) private _rOwned;\r\n-    mapping (address => uint256) private _tOwned;\r\n-    uint256 private constant MAX = ~uint256(0);\r\n-    uint256 private constant _tTotal = 100000000 * 10**8;\r\n-    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n-    uint256 private _tFeeTotal;\r\n-    uint256 private _feeAddr1 = 2;\r\n-\r\n-    event MaxTxAmountUpdated(uint _maxTxAmount);\r\n-\r\n-    constructor () ERC20(_tTotal){\r\n-        _rOwned[msg.sender] = _rTotal;\r\n-        emit Transfer(address(0), msg.sender, _tTotal);\r\n-    }\r\n-\r\n-\r\n-    function totalSupply() public pure override returns (uint256) {\r\n-        return _tTotal;\r\n-    }\r\n-\r\n-    function balanceOf(address account) public view override returns (uint256) {\r\n-        return tokenFromReflection(_rOwned[account]);\r\n-    }\r\n-\r\n-    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\r\n-        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n-        uint256 currentRate =  _getRate();\r\n-        return rAmount.div(currentRate);\r\n-    }\r\n-\r\n-    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\r\n-        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\r\n-        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\r\n-        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n-        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n-        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n-        transferFrom(from,to,amount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\r\n-        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\r\n-        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n-        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n-        _takeTeam(tTeam);\r\n-        _reflectFee(rFee, tFee);\r\n-        emit Transfer(sender, recipient, tTransferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _takeTeam(uint256 tTeam) private {\r\n-        uint256 currentRate =  _getRate();\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\r\n-    }\r\n-\r\n-    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n-        _rTotal = _rTotal.sub(rFee);\r\n-        _tFeeTotal = _tFeeTotal.add(tFee);\r\n-    }\r\n-\r\n-\r\n-    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n-        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\r\n-        uint256 currentRate =  _getRate();\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\r\n-        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 tFee = tAmount.mul(taxFee).div(100);\r\n-        uint256 tTeam = tAmount.mul(TeamFee).div(100);\r\n-        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\r\n-        return (tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 rAmount = tAmount.mul(currentRate);\r\n-        uint256 rFee = tFee.mul(currentRate);\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\r\n-        return (rAmount, rTransferAmount, rFee);\r\n-    }\r\n-\r\n-\tfunction _getRate() private view returns(uint256) {\r\n-        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n-        return rSupply.div(tSupply);\r\n-    }\r\n-\r\n-    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n-        uint256 rSupply = _rTotal;\r\n-        uint256 tSupply = _tTotal;\r\n-        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n-        return (rSupply, tSupply);\r\n-    }\r\n+// SPDX-License-Identifier: MIT\n+\n+pragma solidity ^0.8.16;\n+import \"../ERC20.sol\";\n+\n+contract TCB5_Reflection is ERC20 {\n+    using SafeMath for uint256;\n+    mapping (address => uint256) private _rOwned;\n+    mapping (address => uint256) private _tOwned;\n+    uint256 private constant MAX = ~uint256(0);\n+    uint256 private constant _tTotal = 100000000 * 10**8;\n+    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n+    uint256 private _tFeeTotal;\n+    uint256 private _feeAddr1 = 2;\n+\n+    event MaxTxAmountUpdated(uint _maxTxAmount);\n+\n+    constructor () ERC20(_tTotal){\n+        _rOwned[msg.sender] = _rTotal;\n+        emit Transfer(address(0), msg.sender, _tTotal);\n+    }\n+\n+\n+    function totalSupply() public pure override returns (uint256) {\n+        return _tTotal;\n+    }\n+\n+    function balanceOf(address account) public view override returns (uint256) {\n+        return tokenFromReflection(_rOwned[account]);\n+    }\n+\n+    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\n+        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n+        uint256 currentRate =  _getRate();\n+        return rAmount.div(currentRate);\n+    }\n+\n+    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\n+        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\n+        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\n+        require(from != address(0), \"ERC20: transfer from the zero address\");\n+        require(to != address(0), \"ERC20: transfer to the zero address\");\n+        require(amount > 0, \"Transfer amount must be greater than zero\");\n+        transferFrom(from,to,amount);\n+        return true;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n+        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\n+        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n+        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n+        _takeTeam(tTeam);\n+        _reflectFee(rFee, tFee);\n+        emit Transfer(sender, recipient, tTransferAmount);\n+        return true;\n+    }\n+\n+    function _takeTeam(uint256 tTeam) private {\n+        uint256 currentRate =  _getRate();\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n+    }\n+\n+    function _reflectFee(uint256 rFee, uint256 tFee) private {\n+        _rTotal = _rTotal.sub(rFee);\n+        /// AssignmentMutation(`_tFeeTotal.add(tFee)` |==> `0`) of: `_tFeeTotal = _tFeeTotal.add(tFee);`\n+        _tFeeTotal = 0;\n+    }\n+\n+\n+    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n+        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\n+        uint256 currentRate =  _getRate();\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\n+        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\n+        uint256 tFee = tAmount.mul(taxFee).div(100);\n+        uint256 tTeam = tAmount.mul(TeamFee).div(100);\n+        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n+        return (tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n+        uint256 rAmount = tAmount.mul(currentRate);\n+        uint256 rFee = tFee.mul(currentRate);\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n+        return (rAmount, rTransferAmount, rFee);\n+    }\n+\n+\tfunction _getRate() private view returns(uint256) {\n+        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n+        return rSupply.div(tSupply);\n+    }\n+\n+    function _getCurrentSupply() private view returns(uint256, uint256) {\n+        uint256 rSupply = _rTotal;\n+        uint256 tSupply = _tTotal;\n+        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n+        return (rSupply, tSupply);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "59",
    "name": "mutants/59/TCB5_Reflection.sol",
    "original": "TCB5_Reflection.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,104 +1,105 @@\n-// SPDX-License-Identifier: MIT\r\n-\r\n-pragma solidity ^0.8.16;\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB5_Reflection is ERC20 {\r\n-    using SafeMath for uint256;\r\n-    mapping (address => uint256) private _rOwned;\r\n-    mapping (address => uint256) private _tOwned;\r\n-    uint256 private constant MAX = ~uint256(0);\r\n-    uint256 private constant _tTotal = 100000000 * 10**8;\r\n-    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n-    uint256 private _tFeeTotal;\r\n-    uint256 private _feeAddr1 = 2;\r\n-\r\n-    event MaxTxAmountUpdated(uint _maxTxAmount);\r\n-\r\n-    constructor () ERC20(_tTotal){\r\n-        _rOwned[msg.sender] = _rTotal;\r\n-        emit Transfer(address(0), msg.sender, _tTotal);\r\n-    }\r\n-\r\n-\r\n-    function totalSupply() public pure override returns (uint256) {\r\n-        return _tTotal;\r\n-    }\r\n-\r\n-    function balanceOf(address account) public view override returns (uint256) {\r\n-        return tokenFromReflection(_rOwned[account]);\r\n-    }\r\n-\r\n-    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\r\n-        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n-        uint256 currentRate =  _getRate();\r\n-        return rAmount.div(currentRate);\r\n-    }\r\n-\r\n-    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\r\n-        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\r\n-        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\r\n-        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n-        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n-        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n-        transferFrom(from,to,amount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\r\n-        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\r\n-        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n-        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n-        _takeTeam(tTeam);\r\n-        _reflectFee(rFee, tFee);\r\n-        emit Transfer(sender, recipient, tTransferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function _takeTeam(uint256 tTeam) private {\r\n-        uint256 currentRate =  _getRate();\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\r\n-    }\r\n-\r\n-    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n-        _rTotal = _rTotal.sub(rFee);\r\n-        _tFeeTotal = _tFeeTotal.add(tFee);\r\n-    }\r\n-\r\n-\r\n-    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n-        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\r\n-        uint256 currentRate =  _getRate();\r\n-        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\r\n-        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 tFee = tAmount.mul(taxFee).div(100);\r\n-        uint256 tTeam = tAmount.mul(TeamFee).div(100);\r\n-        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\r\n-        return (tTransferAmount, tFee, tTeam);\r\n-    }\r\n-\r\n-    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n-        uint256 rAmount = tAmount.mul(currentRate);\r\n-        uint256 rFee = tFee.mul(currentRate);\r\n-        uint256 rTeam = tTeam.mul(currentRate);\r\n-        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\r\n-        return (rAmount, rTransferAmount, rFee);\r\n-    }\r\n-\r\n-\tfunction _getRate() private view returns(uint256) {\r\n-        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n-        return rSupply.div(tSupply);\r\n-    }\r\n-\r\n-    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n-        uint256 rSupply = _rTotal;\r\n-        uint256 tSupply = _tTotal;\r\n-        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n-        return (rSupply, tSupply);\r\n-    }\r\n+// SPDX-License-Identifier: MIT\n+\n+pragma solidity ^0.8.16;\n+import \"../ERC20.sol\";\n+\n+contract TCB5_Reflection is ERC20 {\n+    using SafeMath for uint256;\n+    mapping (address => uint256) private _rOwned;\n+    mapping (address => uint256) private _tOwned;\n+    uint256 private constant MAX = ~uint256(0);\n+    uint256 private constant _tTotal = 100000000 * 10**8;\n+    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n+    uint256 private _tFeeTotal;\n+    uint256 private _feeAddr1 = 2;\n+\n+    event MaxTxAmountUpdated(uint _maxTxAmount);\n+\n+    constructor () ERC20(_tTotal){\n+        _rOwned[msg.sender] = _rTotal;\n+        emit Transfer(address(0), msg.sender, _tTotal);\n+    }\n+\n+\n+    function totalSupply() public pure override returns (uint256) {\n+        return _tTotal;\n+    }\n+\n+    function balanceOf(address account) public view override returns (uint256) {\n+        return tokenFromReflection(_rOwned[account]);\n+    }\n+\n+    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\n+        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n+        uint256 currentRate =  _getRate();\n+        return rAmount.div(currentRate);\n+    }\n+\n+    function _transfer(address from, address to, uint256 amount) internal override returns (bool){\n+        require(amount <= _tTotal, \"Exceeds the _maxTxAmount.\");\n+        require(balanceOf(to) + amount <= _tTotal, \"Exceeds the maxWalletSize.\");\n+        require(from != address(0), \"ERC20: transfer from the zero address\");\n+        require(to != address(0), \"ERC20: transfer to the zero address\");\n+        require(amount > 0, \"Transfer amount must be greater than zero\");\n+        transferFrom(from,to,amount);\n+        return true;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 tAmount) public override returns (bool){\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n+        require(rAmount <= _rOwned[sender] && rTransferAmount > 0, \"ERC20: transfer amount over balance\");\n+        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n+        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n+        _takeTeam(tTeam);\n+        _reflectFee(rFee, tFee);\n+        emit Transfer(sender, recipient, tTransferAmount);\n+        return true;\n+    }\n+\n+    function _takeTeam(uint256 tTeam) private {\n+        uint256 currentRate =  _getRate();\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n+    }\n+\n+    function _reflectFee(uint256 rFee, uint256 tFee) private {\n+        _rTotal = _rTotal.sub(rFee);\n+        /// AssignmentMutation(`_tFeeTotal.add(tFee)` |==> `1`) of: `_tFeeTotal = _tFeeTotal.add(tFee);`\n+        _tFeeTotal = 1;\n+    }\n+\n+\n+    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n+        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr1);\n+        uint256 currentRate =  _getRate();\n+        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\n+        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\n+        uint256 tFee = tAmount.mul(taxFee).div(100);\n+        uint256 tTeam = tAmount.mul(TeamFee).div(100);\n+        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n+        return (tTransferAmount, tFee, tTeam);\n+    }\n+\n+    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n+        uint256 rAmount = tAmount.mul(currentRate);\n+        uint256 rFee = tFee.mul(currentRate);\n+        uint256 rTeam = tTeam.mul(currentRate);\n+        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n+        return (rAmount, rTransferAmount, rFee);\n+    }\n+\n+\tfunction _getRate() private view returns(uint256) {\n+        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n+        return rSupply.div(tSupply);\n+    }\n+\n+    function _getCurrentSupply() private view returns(uint256, uint256) {\n+        uint256 rSupply = _rTotal;\n+        uint256 tSupply = _tTotal;\n+        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n+        return (rSupply, tSupply);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "60",
    "name": "mutants/60/TCB5_Reflection.sol",
    "original": "TCB5_Reflection.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,57 +1,58 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); \r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        require(balances[sender] >= amount, \"insufficient-balance\");\r\n-        uint256 swapAmount = amount.mul(swapPercentage).div(100);\r\n-        uint256 transferAmount = amount.sub(swapAmount);\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            _transfer(sender, address(swapContract), swapAmount);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        /// RequireMutation(`address(_swapContract) != address(0)` |==> `true`) of: `require(address(_swapContract) != address(0), \"Invalid swap contract address\");`\n+        require(true, \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); \n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        require(balances[sender] >= amount, \"insufficient-balance\");\n+        uint256 swapAmount = amount.mul(swapPercentage).div(100);\n+        uint256 transferAmount = amount.sub(swapAmount);\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            _transfer(sender, address(swapContract), swapAmount);\n+            _approve(address(this), address(swapContract), swapAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+}\n",
    "id": "61",
    "name": "mutants/61/TCB6_FrontRunSwap.sol",
    "original": "TCB6_FrontRunSwap.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,57 +1,58 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); \r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        require(balances[sender] >= amount, \"insufficient-balance\");\r\n-        uint256 swapAmount = amount.mul(swapPercentage).div(100);\r\n-        uint256 transferAmount = amount.sub(swapAmount);\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            _transfer(sender, address(swapContract), swapAmount);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        /// RequireMutation(`address(_swapContract) != address(0)` |==> `false`) of: `require(address(_swapContract) != address(0), \"Invalid swap contract address\");`\n+        require(false, \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); \n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        require(balances[sender] >= amount, \"insufficient-balance\");\n+        uint256 swapAmount = amount.mul(swapPercentage).div(100);\n+        uint256 transferAmount = amount.sub(swapAmount);\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            _transfer(sender, address(swapContract), swapAmount);\n+            _approve(address(this), address(swapContract), swapAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+}\n",
    "id": "62",
    "name": "mutants/62/TCB6_FrontRunSwap.sol",
    "original": "TCB6_FrontRunSwap.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,57 +1,58 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); \r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        require(balances[sender] >= amount, \"insufficient-balance\");\r\n-        uint256 swapAmount = amount.mul(swapPercentage).div(100);\r\n-        uint256 transferAmount = amount.sub(swapAmount);\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            _transfer(sender, address(swapContract), swapAmount);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); \n+        /// RequireMutation(`tokenToSwapInto != address(0)` |==> `true`) of: `require(tokenToSwapInto != address(0), \"Invalid token address\");`\n+        require(true, \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        require(balances[sender] >= amount, \"insufficient-balance\");\n+        uint256 swapAmount = amount.mul(swapPercentage).div(100);\n+        uint256 transferAmount = amount.sub(swapAmount);\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            _transfer(sender, address(swapContract), swapAmount);\n+            _approve(address(this), address(swapContract), swapAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+}\n",
    "id": "63",
    "name": "mutants/63/TCB6_FrontRunSwap.sol",
    "original": "TCB6_FrontRunSwap.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,57 +1,58 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); \r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        require(balances[sender] >= amount, \"insufficient-balance\");\r\n-        uint256 swapAmount = amount.mul(swapPercentage).div(100);\r\n-        uint256 transferAmount = amount.sub(swapAmount);\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            _transfer(sender, address(swapContract), swapAmount);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); \n+        /// RequireMutation(`tokenToSwapInto != address(0)` |==> `false`) of: `require(tokenToSwapInto != address(0), \"Invalid token address\");`\n+        require(false, \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        require(balances[sender] >= amount, \"insufficient-balance\");\n+        uint256 swapAmount = amount.mul(swapPercentage).div(100);\n+        uint256 transferAmount = amount.sub(swapAmount);\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            _transfer(sender, address(swapContract), swapAmount);\n+            _approve(address(this), address(swapContract), swapAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+}\n",
    "id": "64",
    "name": "mutants/64/TCB6_FrontRunSwap.sol",
    "original": "TCB6_FrontRunSwap.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,57 +1,58 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); \r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        require(balances[sender] >= amount, \"insufficient-balance\");\r\n-        uint256 swapAmount = amount.mul(swapPercentage).div(100);\r\n-        uint256 transferAmount = amount.sub(swapAmount);\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            _transfer(sender, address(swapContract), swapAmount);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); \n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        /// RequireMutation(`_swapPercentage > 0 && _swapPercentage < 100` |==> `true`) of: `require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");`\n+        require(true, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        require(balances[sender] >= amount, \"insufficient-balance\");\n+        uint256 swapAmount = amount.mul(swapPercentage).div(100);\n+        uint256 transferAmount = amount.sub(swapAmount);\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            _transfer(sender, address(swapContract), swapAmount);\n+            _approve(address(this), address(swapContract), swapAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+}\n",
    "id": "65",
    "name": "mutants/65/TCB6_FrontRunSwap.sol",
    "original": "TCB6_FrontRunSwap.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,57 +1,58 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); \r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        require(balances[sender] >= amount, \"insufficient-balance\");\r\n-        uint256 swapAmount = amount.mul(swapPercentage).div(100);\r\n-        uint256 transferAmount = amount.sub(swapAmount);\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            _transfer(sender, address(swapContract), swapAmount);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); \n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        /// RequireMutation(`_swapPercentage > 0 && _swapPercentage < 100` |==> `false`) of: `require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");`\n+        require(false, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        require(balances[sender] >= amount, \"insufficient-balance\");\n+        uint256 swapAmount = amount.mul(swapPercentage).div(100);\n+        uint256 transferAmount = amount.sub(swapAmount);\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            _transfer(sender, address(swapContract), swapAmount);\n+            _approve(address(this), address(swapContract), swapAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+}\n",
    "id": "66",
    "name": "mutants/66/TCB6_FrontRunSwap.sol",
    "original": "TCB6_FrontRunSwap.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,57 +1,58 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); \r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        require(balances[sender] >= amount, \"insufficient-balance\");\r\n-        uint256 swapAmount = amount.mul(swapPercentage).div(100);\r\n-        uint256 transferAmount = amount.sub(swapAmount);\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            _transfer(sender, address(swapContract), swapAmount);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); \n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        /// AssignmentMutation(`_swapPercentage` |==> `0`) of: `swapPercentage = _swapPercentage;`\n+        swapPercentage = 0;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        require(balances[sender] >= amount, \"insufficient-balance\");\n+        uint256 swapAmount = amount.mul(swapPercentage).div(100);\n+        uint256 transferAmount = amount.sub(swapAmount);\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            _transfer(sender, address(swapContract), swapAmount);\n+            _approve(address(this), address(swapContract), swapAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+}\n",
    "id": "67",
    "name": "mutants/67/TCB6_FrontRunSwap.sol",
    "original": "TCB6_FrontRunSwap.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,57 +1,58 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); \r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        require(balances[sender] >= amount, \"insufficient-balance\");\r\n-        uint256 swapAmount = amount.mul(swapPercentage).div(100);\r\n-        uint256 transferAmount = amount.sub(swapAmount);\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            _transfer(sender, address(swapContract), swapAmount);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); \n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        /// AssignmentMutation(`_swapPercentage` |==> `1`) of: `swapPercentage = _swapPercentage;`\n+        swapPercentage = 1;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        require(balances[sender] >= amount, \"insufficient-balance\");\n+        uint256 swapAmount = amount.mul(swapPercentage).div(100);\n+        uint256 transferAmount = amount.sub(swapAmount);\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            _transfer(sender, address(swapContract), swapAmount);\n+            _approve(address(this), address(swapContract), swapAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+}\n",
    "id": "68",
    "name": "mutants/68/TCB6_FrontRunSwap.sol",
    "original": "TCB6_FrontRunSwap.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,57 +1,58 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); \r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        require(balances[sender] >= amount, \"insufficient-balance\");\r\n-        uint256 swapAmount = amount.mul(swapPercentage).div(100);\r\n-        uint256 transferAmount = amount.sub(swapAmount);\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            _transfer(sender, address(swapContract), swapAmount);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); \n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        /// RequireMutation(`balances[sender] >= amount` |==> `true`) of: `require(balances[sender] >= amount, \"insufficient-balance\");`\n+        require(true, \"insufficient-balance\");\n+        uint256 swapAmount = amount.mul(swapPercentage).div(100);\n+        uint256 transferAmount = amount.sub(swapAmount);\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            _transfer(sender, address(swapContract), swapAmount);\n+            _approve(address(this), address(swapContract), swapAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+}\n",
    "id": "69",
    "name": "mutants/69/TCB6_FrontRunSwap.sol",
    "original": "TCB6_FrontRunSwap.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,57 +1,58 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); \r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        require(balances[sender] >= amount, \"insufficient-balance\");\r\n-        uint256 swapAmount = amount.mul(swapPercentage).div(100);\r\n-        uint256 transferAmount = amount.sub(swapAmount);\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            _transfer(sender, address(swapContract), swapAmount);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB6_FrontRunSwap is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); \n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        /// RequireMutation(`balances[sender] >= amount` |==> `false`) of: `require(balances[sender] >= amount, \"insufficient-balance\");`\n+        require(false, \"insufficient-balance\");\n+        uint256 swapAmount = amount.mul(swapPercentage).div(100);\n+        uint256 transferAmount = amount.sub(swapAmount);\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            _transfer(sender, address(swapContract), swapAmount);\n+            _approve(address(this), address(swapContract), swapAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+}\n",
    "id": "70",
    "name": "mutants/70/TCB6_FrontRunSwap.sol",
    "original": "TCB6_FrontRunSwap.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,62 +1,63 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity 0.8.19;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\r\n-        uint256 transferAmount = amount - swapAmount;\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            uint256 half = swapAmount.div(2);\r\n-            _transfer(sender, address(swapContract), half);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\r\n-            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\r\n-            // swapContract.addLiquidity(swapAmount, swappedAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity 0.8.19;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        /// RequireMutation(`address(_swapContract) != address(0)` |==> `true`) of: `require(address(_swapContract) != address(0), \"Invalid swap contract address\");`\n+        require(true, \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\n+        uint256 transferAmount = amount - swapAmount;\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            uint256 half = swapAmount.div(2);\n+            _transfer(sender, address(swapContract), half);\n+            _approve(address(this), address(swapContract), swapAmount);\n+            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\n+            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\n+            // swapContract.addLiquidity(swapAmount, swappedAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+\n+}\n",
    "id": "71",
    "name": "mutants/71/TCB7_FrontRunAddLiq.sol",
    "original": "TCB7_FrontRunAddLiq.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,62 +1,63 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity 0.8.19;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\r\n-        uint256 transferAmount = amount - swapAmount;\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            uint256 half = swapAmount.div(2);\r\n-            _transfer(sender, address(swapContract), half);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\r\n-            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\r\n-            // swapContract.addLiquidity(swapAmount, swappedAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity 0.8.19;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        /// RequireMutation(`address(_swapContract) != address(0)` |==> `false`) of: `require(address(_swapContract) != address(0), \"Invalid swap contract address\");`\n+        require(false, \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\n+        uint256 transferAmount = amount - swapAmount;\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            uint256 half = swapAmount.div(2);\n+            _transfer(sender, address(swapContract), half);\n+            _approve(address(this), address(swapContract), swapAmount);\n+            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\n+            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\n+            // swapContract.addLiquidity(swapAmount, swappedAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+\n+}\n",
    "id": "72",
    "name": "mutants/72/TCB7_FrontRunAddLiq.sol",
    "original": "TCB7_FrontRunAddLiq.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,62 +1,63 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity 0.8.19;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\r\n-        uint256 transferAmount = amount - swapAmount;\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            uint256 half = swapAmount.div(2);\r\n-            _transfer(sender, address(swapContract), half);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\r\n-            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\r\n-            // swapContract.addLiquidity(swapAmount, swappedAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity 0.8.19;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\n+        /// RequireMutation(`tokenToSwapInto != address(0)` |==> `true`) of: `require(tokenToSwapInto != address(0), \"Invalid token address\");`\n+        require(true, \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\n+        uint256 transferAmount = amount - swapAmount;\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            uint256 half = swapAmount.div(2);\n+            _transfer(sender, address(swapContract), half);\n+            _approve(address(this), address(swapContract), swapAmount);\n+            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\n+            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\n+            // swapContract.addLiquidity(swapAmount, swappedAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+\n+}\n",
    "id": "73",
    "name": "mutants/73/TCB7_FrontRunAddLiq.sol",
    "original": "TCB7_FrontRunAddLiq.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,62 +1,63 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity 0.8.19;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\r\n-        uint256 transferAmount = amount - swapAmount;\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            uint256 half = swapAmount.div(2);\r\n-            _transfer(sender, address(swapContract), half);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\r\n-            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\r\n-            // swapContract.addLiquidity(swapAmount, swappedAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity 0.8.19;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\n+        /// RequireMutation(`tokenToSwapInto != address(0)` |==> `false`) of: `require(tokenToSwapInto != address(0), \"Invalid token address\");`\n+        require(false, \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\n+        uint256 transferAmount = amount - swapAmount;\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            uint256 half = swapAmount.div(2);\n+            _transfer(sender, address(swapContract), half);\n+            _approve(address(this), address(swapContract), swapAmount);\n+            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\n+            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\n+            // swapContract.addLiquidity(swapAmount, swappedAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+\n+}\n",
    "id": "74",
    "name": "mutants/74/TCB7_FrontRunAddLiq.sol",
    "original": "TCB7_FrontRunAddLiq.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,62 +1,63 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity 0.8.19;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\r\n-        uint256 transferAmount = amount - swapAmount;\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            uint256 half = swapAmount.div(2);\r\n-            _transfer(sender, address(swapContract), half);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\r\n-            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\r\n-            // swapContract.addLiquidity(swapAmount, swappedAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity 0.8.19;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        /// RequireMutation(`_swapPercentage > 0 && _swapPercentage < 100` |==> `true`) of: `require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");`\n+        require(true, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\n+        uint256 transferAmount = amount - swapAmount;\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            uint256 half = swapAmount.div(2);\n+            _transfer(sender, address(swapContract), half);\n+            _approve(address(this), address(swapContract), swapAmount);\n+            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\n+            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\n+            // swapContract.addLiquidity(swapAmount, swappedAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+\n+}\n",
    "id": "75",
    "name": "mutants/75/TCB7_FrontRunAddLiq.sol",
    "original": "TCB7_FrontRunAddLiq.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,62 +1,63 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity 0.8.19;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\r\n-        uint256 transferAmount = amount - swapAmount;\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            uint256 half = swapAmount.div(2);\r\n-            _transfer(sender, address(swapContract), half);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\r\n-            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\r\n-            // swapContract.addLiquidity(swapAmount, swappedAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity 0.8.19;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        /// RequireMutation(`_swapPercentage > 0 && _swapPercentage < 100` |==> `false`) of: `require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");`\n+        require(false, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        swapPercentage = _swapPercentage;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\n+        uint256 transferAmount = amount - swapAmount;\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            uint256 half = swapAmount.div(2);\n+            _transfer(sender, address(swapContract), half);\n+            _approve(address(this), address(swapContract), swapAmount);\n+            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\n+            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\n+            // swapContract.addLiquidity(swapAmount, swappedAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+\n+}\n",
    "id": "76",
    "name": "mutants/76/TCB7_FrontRunAddLiq.sol",
    "original": "TCB7_FrontRunAddLiq.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,62 +1,63 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity 0.8.19;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\r\n-        uint256 transferAmount = amount - swapAmount;\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            uint256 half = swapAmount.div(2);\r\n-            _transfer(sender, address(swapContract), half);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\r\n-            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\r\n-            // swapContract.addLiquidity(swapAmount, swappedAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity 0.8.19;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        /// AssignmentMutation(`_swapPercentage` |==> `0`) of: `swapPercentage = _swapPercentage;`\n+        swapPercentage = 0;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\n+        uint256 transferAmount = amount - swapAmount;\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            uint256 half = swapAmount.div(2);\n+            _transfer(sender, address(swapContract), half);\n+            _approve(address(this), address(swapContract), swapAmount);\n+            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\n+            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\n+            // swapContract.addLiquidity(swapAmount, swappedAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+\n+}\n",
    "id": "77",
    "name": "mutants/77/TCB7_FrontRunAddLiq.sol",
    "original": "TCB7_FrontRunAddLiq.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,62 +1,63 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity 0.8.19;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-interface ISimpleSwap {\r\n-    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\r\n-    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n-    function getTokenA() external view returns (address);\r\n-    function getTokenB() external view returns (address);\r\n-}\r\n-\r\n-contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\r\n-    ISimpleSwap public swapContract;\r\n-    address public tokenToSwapInto;\r\n-    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\r\n-    using SafeMath for uint;\r\n-\r\n-    constructor(\r\n-        uint _totalSupply,\r\n-        ISimpleSwap _swapContract,\r\n-        uint256 _swapPercentage\r\n-    ) ERC20(_totalSupply) {\r\n-        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\r\n-        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\r\n-        require(tokenToSwapInto != address(0), \"Invalid token address\");\r\n-        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\r\n-\r\n-        swapContract = _swapContract;\r\n-        swapPercentage = _swapPercentage;\r\n-    }\r\n-\r\n-    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n-        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\r\n-        uint256 transferAmount = amount - swapAmount;\r\n-\r\n-        // 先执行swap操作\r\n-        if (swapAmount > 0) {\r\n-            uint256 half = swapAmount.div(2);\r\n-            _transfer(sender, address(swapContract), half);\r\n-            _approve(address(this), address(swapContract), swapAmount);\r\n-            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\r\n-            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\r\n-            // swapContract.addLiquidity(swapAmount, swappedAmount);\r\n-        }\r\n-\r\n-        // 然后执行正常的transferFrom操作\r\n-        _transfer(sender, recipient, transferAmount);\r\n-        return true;\r\n-    }\r\n-\r\n-    function getSwapAddress() public view returns (address) {\r\n-        return address(swapContract);\r\n-    }\r\n-\r\n-    function getSwapPercentage() public view returns (uint256) {\r\n-        return swapPercentage;\r\n-    }\r\n-\r\n-\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity 0.8.19;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+interface ISimpleSwap {\n+    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);\n+    function addLiquidity(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n+    function getTokenA() external view returns (address);\n+    function getTokenB() external view returns (address);\n+}\n+\n+contract TCB7_FrontRunAddLiq is ERC20, ReentrancyGuard {\n+    ISimpleSwap public swapContract;\n+    address public tokenToSwapInto;\n+    uint256 public swapPercentage; // 以百分比形式表示，例如10表示10%\n+    using SafeMath for uint;\n+\n+    constructor(\n+        uint _totalSupply,\n+        ISimpleSwap _swapContract,\n+        uint256 _swapPercentage\n+    ) ERC20(_totalSupply) {\n+        require(address(_swapContract) != address(0), \"Invalid swap contract address\");\n+        tokenToSwapInto = _swapContract.getTokenB(); // 假设当前合约代币为TokenA，要交换成TokenB\n+        require(tokenToSwapInto != address(0), \"Invalid token address\");\n+        require(_swapPercentage > 0 && _swapPercentage < 100, \"Invalid swap percentage\");\n+\n+        swapContract = _swapContract;\n+        /// AssignmentMutation(`_swapPercentage` |==> `1`) of: `swapPercentage = _swapPercentage;`\n+        swapPercentage = 1;\n+    }\n+\n+    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n+        uint256 swapAmount = (amount.mul(swapPercentage)).div(100);\n+        uint256 transferAmount = amount - swapAmount;\n+\n+        // 先执行swap操作\n+        if (swapAmount > 0) {\n+            uint256 half = swapAmount.div(2);\n+            _transfer(sender, address(swapContract), half);\n+            _approve(address(this), address(swapContract), swapAmount);\n+            // uint256 swappedAmount = swapContract.swap(address(this), tokenToSwapInto, half);\n+            // ERC20(tokenToSwapInto).approve(address(swapContract), swappedAmount);\n+            // swapContract.addLiquidity(swapAmount, swappedAmount);\n+        }\n+\n+        // 然后执行正常的transferFrom操作\n+        _transfer(sender, recipient, transferAmount);\n+        return true;\n+    }\n+\n+    function getSwapAddress() public view returns (address) {\n+        return address(swapContract);\n+    }\n+\n+    function getSwapPercentage() public view returns (uint256) {\n+        return swapPercentage;\n+    }\n+\n+\n+}\n",
    "id": "78",
    "name": "mutants/78/TCB7_FrontRunAddLiq.sol",
    "original": "TCB7_FrontRunAddLiq.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,29 +1,30 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB8_Frozen is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- BlockList ---\r\n-    mapping(address => bool) blocked;\r\n-    function blockUser(address usr) auth public { blocked[usr] = true; }\r\n-    function allow(address usr) auth public { blocked[usr] = false; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(!blocked[src], \"blocked\");\r\n-        require(!blocked[dst], \"blocked\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB8_Frozen is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    /// RequireMutation(`msg.sender == owner` |==> `true`) of: `modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }`\n+    modifier auth() { require(true, \"unauthorised\"); _; }\n+\n+    // --- BlockList ---\n+    mapping(address => bool) blocked;\n+    function blockUser(address usr) auth public { blocked[usr] = true; }\n+    function allow(address usr) auth public { blocked[usr] = false; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(!blocked[src], \"blocked\");\n+        require(!blocked[dst], \"blocked\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "79",
    "name": "mutants/79/TCB8_Frozen.sol",
    "original": "TCB8_Frozen.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,29 +1,30 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB8_Frozen is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- BlockList ---\r\n-    mapping(address => bool) blocked;\r\n-    function blockUser(address usr) auth public { blocked[usr] = true; }\r\n-    function allow(address usr) auth public { blocked[usr] = false; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(!blocked[src], \"blocked\");\r\n-        require(!blocked[dst], \"blocked\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB8_Frozen is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    /// RequireMutation(`msg.sender == owner` |==> `false`) of: `modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }`\n+    modifier auth() { require(false, \"unauthorised\"); _; }\n+\n+    // --- BlockList ---\n+    mapping(address => bool) blocked;\n+    function blockUser(address usr) auth public { blocked[usr] = true; }\n+    function allow(address usr) auth public { blocked[usr] = false; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(!blocked[src], \"blocked\");\n+        require(!blocked[dst], \"blocked\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "80",
    "name": "mutants/80/TCB8_Frozen.sol",
    "original": "TCB8_Frozen.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,29 +1,30 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB8_Frozen is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- BlockList ---\r\n-    mapping(address => bool) blocked;\r\n-    function blockUser(address usr) auth public { blocked[usr] = true; }\r\n-    function allow(address usr) auth public { blocked[usr] = false; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(!blocked[src], \"blocked\");\r\n-        require(!blocked[dst], \"blocked\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB8_Frozen is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- BlockList ---\n+    mapping(address => bool) blocked;\n+    /// AssignmentMutation(`true` |==> `false`) of: `function blockUser(address usr) auth public { blocked[usr] = true; }`\n+    function blockUser(address usr) auth public { blocked[usr] = false; }\n+    function allow(address usr) auth public { blocked[usr] = false; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(!blocked[src], \"blocked\");\n+        require(!blocked[dst], \"blocked\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "81",
    "name": "mutants/81/TCB8_Frozen.sol",
    "original": "TCB8_Frozen.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,29 +1,30 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB8_Frozen is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- BlockList ---\r\n-    mapping(address => bool) blocked;\r\n-    function blockUser(address usr) auth public { blocked[usr] = true; }\r\n-    function allow(address usr) auth public { blocked[usr] = false; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(!blocked[src], \"blocked\");\r\n-        require(!blocked[dst], \"blocked\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB8_Frozen is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- BlockList ---\n+    mapping(address => bool) blocked;\n+    function blockUser(address usr) auth public { blocked[usr] = true; }\n+    /// AssignmentMutation(`false` |==> `true`) of: `function allow(address usr) auth public { blocked[usr] = false; }`\n+    function allow(address usr) auth public { blocked[usr] = true; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(!blocked[src], \"blocked\");\n+        require(!blocked[dst], \"blocked\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "82",
    "name": "mutants/82/TCB8_Frozen.sol",
    "original": "TCB8_Frozen.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,29 +1,30 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB8_Frozen is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- BlockList ---\r\n-    mapping(address => bool) blocked;\r\n-    function blockUser(address usr) auth public { blocked[usr] = true; }\r\n-    function allow(address usr) auth public { blocked[usr] = false; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(!blocked[src], \"blocked\");\r\n-        require(!blocked[dst], \"blocked\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB8_Frozen is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- BlockList ---\n+    mapping(address => bool) blocked;\n+    function blockUser(address usr) auth public { blocked[usr] = true; }\n+    function allow(address usr) auth public { blocked[usr] = false; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        /// RequireMutation(`!blocked[src]` |==> `true`) of: `require(!blocked[src], \"blocked\");`\n+        require(true, \"blocked\");\n+        require(!blocked[dst], \"blocked\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "83",
    "name": "mutants/83/TCB8_Frozen.sol",
    "original": "TCB8_Frozen.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,29 +1,30 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB8_Frozen is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- BlockList ---\r\n-    mapping(address => bool) blocked;\r\n-    function blockUser(address usr) auth public { blocked[usr] = true; }\r\n-    function allow(address usr) auth public { blocked[usr] = false; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(!blocked[src], \"blocked\");\r\n-        require(!blocked[dst], \"blocked\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB8_Frozen is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- BlockList ---\n+    mapping(address => bool) blocked;\n+    function blockUser(address usr) auth public { blocked[usr] = true; }\n+    function allow(address usr) auth public { blocked[usr] = false; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        /// RequireMutation(`!blocked[src]` |==> `false`) of: `require(!blocked[src], \"blocked\");`\n+        require(false, \"blocked\");\n+        require(!blocked[dst], \"blocked\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "84",
    "name": "mutants/84/TCB8_Frozen.sol",
    "original": "TCB8_Frozen.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,29 +1,30 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB8_Frozen is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- BlockList ---\r\n-    mapping(address => bool) blocked;\r\n-    function blockUser(address usr) auth public { blocked[usr] = true; }\r\n-    function allow(address usr) auth public { blocked[usr] = false; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(!blocked[src], \"blocked\");\r\n-        require(!blocked[dst], \"blocked\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB8_Frozen is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- BlockList ---\n+    mapping(address => bool) blocked;\n+    function blockUser(address usr) auth public { blocked[usr] = true; }\n+    function allow(address usr) auth public { blocked[usr] = false; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(!blocked[src], \"blocked\");\n+        /// RequireMutation(`!blocked[dst]` |==> `true`) of: `require(!blocked[dst], \"blocked\");`\n+        require(true, \"blocked\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "85",
    "name": "mutants/85/TCB8_Frozen.sol",
    "original": "TCB8_Frozen.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,29 +1,30 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import \"../ERC20.sol\";\r\n-\r\n-contract TCB8_Frozen is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- BlockList ---\r\n-    mapping(address => bool) blocked;\r\n-    function blockUser(address usr) auth public { blocked[usr] = true; }\r\n-    function allow(address usr) auth public { blocked[usr] = false; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply) {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(!blocked[src], \"blocked\");\r\n-        require(!blocked[dst], \"blocked\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import \"../ERC20.sol\";\n+\n+contract TCB8_Frozen is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- BlockList ---\n+    mapping(address => bool) blocked;\n+    function blockUser(address usr) auth public { blocked[usr] = true; }\n+    function allow(address usr) auth public { blocked[usr] = false; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply) {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(!blocked[src], \"blocked\");\n+        /// RequireMutation(`!blocked[dst]` |==> `false`) of: `require(!blocked[dst], \"blocked\");`\n+        require(false, \"blocked\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "86",
    "name": "mutants/86/TCB8_Frozen.sol",
    "original": "TCB8_Frozen.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,36 +1,37 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import {ERC20} from \"../ERC20.sol\";\r\n-\r\n-contract TCB9_Pause is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- Pause ---\r\n-    bool live = true;\r\n-    function stop() auth external { live = false; }\r\n-    function start() auth external { live = true; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply)  {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function approve(address usr, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.approve(usr, wad);\r\n-    }\r\n-    function transfer(address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transfer(dst, wad);\r\n-    }\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import {ERC20} from \"../ERC20.sol\";\n+\n+contract TCB9_Pause is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    /// RequireMutation(`msg.sender == owner` |==> `true`) of: `modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }`\n+    modifier auth() { require(true, \"unauthorised\"); _; }\n+\n+    // --- Pause ---\n+    bool live = true;\n+    function stop() auth external { live = false; }\n+    function start() auth external { live = true; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply)  {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function approve(address usr, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.approve(usr, wad);\n+    }\n+    function transfer(address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transfer(dst, wad);\n+    }\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "87",
    "name": "mutants/87/TCB9_Pause.sol",
    "original": "TCB9_Pause.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,36 +1,37 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import {ERC20} from \"../ERC20.sol\";\r\n-\r\n-contract TCB9_Pause is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- Pause ---\r\n-    bool live = true;\r\n-    function stop() auth external { live = false; }\r\n-    function start() auth external { live = true; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply)  {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function approve(address usr, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.approve(usr, wad);\r\n-    }\r\n-    function transfer(address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transfer(dst, wad);\r\n-    }\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import {ERC20} from \"../ERC20.sol\";\n+\n+contract TCB9_Pause is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    /// RequireMutation(`msg.sender == owner` |==> `false`) of: `modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }`\n+    modifier auth() { require(false, \"unauthorised\"); _; }\n+\n+    // --- Pause ---\n+    bool live = true;\n+    function stop() auth external { live = false; }\n+    function start() auth external { live = true; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply)  {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function approve(address usr, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.approve(usr, wad);\n+    }\n+    function transfer(address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transfer(dst, wad);\n+    }\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "88",
    "name": "mutants/88/TCB9_Pause.sol",
    "original": "TCB9_Pause.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,36 +1,37 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import {ERC20} from \"../ERC20.sol\";\r\n-\r\n-contract TCB9_Pause is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- Pause ---\r\n-    bool live = true;\r\n-    function stop() auth external { live = false; }\r\n-    function start() auth external { live = true; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply)  {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function approve(address usr, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.approve(usr, wad);\r\n-    }\r\n-    function transfer(address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transfer(dst, wad);\r\n-    }\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import {ERC20} from \"../ERC20.sol\";\n+\n+contract TCB9_Pause is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- Pause ---\n+    bool live = true;\n+    /// AssignmentMutation(`false` |==> `true`) of: `function stop() auth external { live = false; }`\n+    function stop() auth external { live = true; }\n+    function start() auth external { live = true; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply)  {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function approve(address usr, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.approve(usr, wad);\n+    }\n+    function transfer(address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transfer(dst, wad);\n+    }\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "89",
    "name": "mutants/89/TCB9_Pause.sol",
    "original": "TCB9_Pause.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,36 +1,37 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import {ERC20} from \"../ERC20.sol\";\r\n-\r\n-contract TCB9_Pause is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- Pause ---\r\n-    bool live = true;\r\n-    function stop() auth external { live = false; }\r\n-    function start() auth external { live = true; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply)  {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function approve(address usr, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.approve(usr, wad);\r\n-    }\r\n-    function transfer(address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transfer(dst, wad);\r\n-    }\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import {ERC20} from \"../ERC20.sol\";\n+\n+contract TCB9_Pause is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- Pause ---\n+    bool live = true;\n+    function stop() auth external { live = false; }\n+    /// AssignmentMutation(`true` |==> `false`) of: `function start() auth external { live = true; }`\n+    function start() auth external { live = false; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply)  {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function approve(address usr, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.approve(usr, wad);\n+    }\n+    function transfer(address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transfer(dst, wad);\n+    }\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "90",
    "name": "mutants/90/TCB9_Pause.sol",
    "original": "TCB9_Pause.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,36 +1,37 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import {ERC20} from \"../ERC20.sol\";\r\n-\r\n-contract TCB9_Pause is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- Pause ---\r\n-    bool live = true;\r\n-    function stop() auth external { live = false; }\r\n-    function start() auth external { live = true; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply)  {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function approve(address usr, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.approve(usr, wad);\r\n-    }\r\n-    function transfer(address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transfer(dst, wad);\r\n-    }\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import {ERC20} from \"../ERC20.sol\";\n+\n+contract TCB9_Pause is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- Pause ---\n+    bool live = true;\n+    function stop() auth external { live = false; }\n+    function start() auth external { live = true; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply)  {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function approve(address usr, uint wad) override public returns (bool) {\n+        /// RequireMutation(`live` |==> `true`) of: `require(live, \"paused\");`\n+        require(true, \"paused\");\n+        return super.approve(usr, wad);\n+    }\n+    function transfer(address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transfer(dst, wad);\n+    }\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "91",
    "name": "mutants/91/TCB9_Pause.sol",
    "original": "TCB9_Pause.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,36 +1,37 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import {ERC20} from \"../ERC20.sol\";\r\n-\r\n-contract TCB9_Pause is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- Pause ---\r\n-    bool live = true;\r\n-    function stop() auth external { live = false; }\r\n-    function start() auth external { live = true; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply)  {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function approve(address usr, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.approve(usr, wad);\r\n-    }\r\n-    function transfer(address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transfer(dst, wad);\r\n-    }\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import {ERC20} from \"../ERC20.sol\";\n+\n+contract TCB9_Pause is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- Pause ---\n+    bool live = true;\n+    function stop() auth external { live = false; }\n+    function start() auth external { live = true; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply)  {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function approve(address usr, uint wad) override public returns (bool) {\n+        /// RequireMutation(`live` |==> `false`) of: `require(live, \"paused\");`\n+        require(false, \"paused\");\n+        return super.approve(usr, wad);\n+    }\n+    function transfer(address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transfer(dst, wad);\n+    }\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "92",
    "name": "mutants/92/TCB9_Pause.sol",
    "original": "TCB9_Pause.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,36 +1,37 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import {ERC20} from \"../ERC20.sol\";\r\n-\r\n-contract TCB9_Pause is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- Pause ---\r\n-    bool live = true;\r\n-    function stop() auth external { live = false; }\r\n-    function start() auth external { live = true; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply)  {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function approve(address usr, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.approve(usr, wad);\r\n-    }\r\n-    function transfer(address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transfer(dst, wad);\r\n-    }\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import {ERC20} from \"../ERC20.sol\";\n+\n+contract TCB9_Pause is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- Pause ---\n+    bool live = true;\n+    function stop() auth external { live = false; }\n+    function start() auth external { live = true; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply)  {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function approve(address usr, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.approve(usr, wad);\n+    }\n+    function transfer(address dst, uint wad) override public returns (bool) {\n+        /// RequireMutation(`live` |==> `true`) of: `require(live, \"paused\");`\n+        require(true, \"paused\");\n+        return super.transfer(dst, wad);\n+    }\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "93",
    "name": "mutants/93/TCB9_Pause.sol",
    "original": "TCB9_Pause.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,36 +1,37 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import {ERC20} from \"../ERC20.sol\";\r\n-\r\n-contract TCB9_Pause is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- Pause ---\r\n-    bool live = true;\r\n-    function stop() auth external { live = false; }\r\n-    function start() auth external { live = true; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply)  {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function approve(address usr, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.approve(usr, wad);\r\n-    }\r\n-    function transfer(address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transfer(dst, wad);\r\n-    }\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import {ERC20} from \"../ERC20.sol\";\n+\n+contract TCB9_Pause is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- Pause ---\n+    bool live = true;\n+    function stop() auth external { live = false; }\n+    function start() auth external { live = true; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply)  {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function approve(address usr, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.approve(usr, wad);\n+    }\n+    function transfer(address dst, uint wad) override public returns (bool) {\n+        /// RequireMutation(`live` |==> `false`) of: `require(live, \"paused\");`\n+        require(false, \"paused\");\n+        return super.transfer(dst, wad);\n+    }\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "94",
    "name": "mutants/94/TCB9_Pause.sol",
    "original": "TCB9_Pause.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,36 +1,37 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import {ERC20} from \"../ERC20.sol\";\r\n-\r\n-contract TCB9_Pause is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- Pause ---\r\n-    bool live = true;\r\n-    function stop() auth external { live = false; }\r\n-    function start() auth external { live = true; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply)  {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function approve(address usr, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.approve(usr, wad);\r\n-    }\r\n-    function transfer(address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transfer(dst, wad);\r\n-    }\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import {ERC20} from \"../ERC20.sol\";\n+\n+contract TCB9_Pause is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- Pause ---\n+    bool live = true;\n+    function stop() auth external { live = false; }\n+    function start() auth external { live = true; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply)  {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function approve(address usr, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.approve(usr, wad);\n+    }\n+    function transfer(address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transfer(dst, wad);\n+    }\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        /// RequireMutation(`live` |==> `true`) of: `require(live, \"paused\");`\n+        require(true, \"paused\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "95",
    "name": "mutants/95/TCB9_Pause.sol",
    "original": "TCB9_Pause.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,36 +1,37 @@\n-// Copyright (C) 2020 d-xo\r\n-// SPDX-License-Identifier: AGPL-3.0-only\r\n-\r\n-pragma solidity >=0.6.12;\r\n-\r\n-import {ERC20} from \"../ERC20.sol\";\r\n-\r\n-contract TCB9_Pause is ERC20 {\r\n-    // --- Access Control ---\r\n-    address owner;\r\n-    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\r\n-\r\n-    // --- Pause ---\r\n-    bool live = true;\r\n-    function stop() auth external { live = false; }\r\n-    function start() auth external { live = true; }\r\n-\r\n-    // --- Init ---\r\n-    constructor(uint _totalSupply) ERC20(_totalSupply)  {\r\n-        owner = msg.sender;\r\n-    }\r\n-\r\n-    // --- Token ---\r\n-    function approve(address usr, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.approve(usr, wad);\r\n-    }\r\n-    function transfer(address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transfer(dst, wad);\r\n-    }\r\n-    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\r\n-        require(live, \"paused\");\r\n-        return super.transferFrom(src, dst, wad);\r\n-    }\r\n+// Copyright (C) 2020 d-xo\n+// SPDX-License-Identifier: AGPL-3.0-only\n+\n+pragma solidity >=0.6.12;\n+\n+import {ERC20} from \"../ERC20.sol\";\n+\n+contract TCB9_Pause is ERC20 {\n+    // --- Access Control ---\n+    address owner;\n+    modifier auth() { require(msg.sender == owner, \"unauthorised\"); _; }\n+\n+    // --- Pause ---\n+    bool live = true;\n+    function stop() auth external { live = false; }\n+    function start() auth external { live = true; }\n+\n+    // --- Init ---\n+    constructor(uint _totalSupply) ERC20(_totalSupply)  {\n+        owner = msg.sender;\n+    }\n+\n+    // --- Token ---\n+    function approve(address usr, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.approve(usr, wad);\n+    }\n+    function transfer(address dst, uint wad) override public returns (bool) {\n+        require(live, \"paused\");\n+        return super.transfer(dst, wad);\n+    }\n+    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n+        /// RequireMutation(`live` |==> `false`) of: `require(live, \"paused\");`\n+        require(false, \"paused\");\n+        return super.transferFrom(src, dst, wad);\n+    }\n }\n\\ No newline at end of file\n",
    "id": "96",
    "name": "mutants/96/TCB9_Pause.sol",
    "original": "TCB9_Pause.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,42 +1,43 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-contract TCB10_FlashMint is ERC20, ReentrancyGuard {\r\n-    uint256 private constant MAX_SUPPLY = type(uint256).max;\r\n-    uint256 public flashMintFee;\r\n-    uint256 public feePrecision = 1000;\r\n-\r\n-    // FlashMint 事件\r\n-    event FlashMint(address indexed to, uint256 amount);\r\n-\r\n-    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\r\n-        require(_fee < 100, \"FlashMint: fee too high\");\r\n-        flashMintFee = _fee;\r\n-    }\r\n-\r\n-    function calcPremium(uint256 amount) public view returns (uint256){\r\n-        return ((amount*flashMintFee)/feePrecision);\r\n-    }\r\n-\r\n-    // FlashMint 函数\r\n-    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\r\n-        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\r\n-        uint256 totalPremium = calcPremium(amount);\r\n-\r\n-        uint256 amountPlusPremium = amount + totalPremium;\r\n-        _mint(receiverAddress, amount);\r\n-\r\n-        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\r\n-\r\n-        _burn(receiverAddress, amountPlusPremium);\r\n-\r\n-        emit FlashMint(receiverAddress, amount);\r\n-    }\r\n-}\r\n-\r\n-interface IFlashMintReceiver {\r\n-    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+contract TCB10_FlashMint is ERC20, ReentrancyGuard {\n+    uint256 private constant MAX_SUPPLY = type(uint256).max;\n+    uint256 public flashMintFee;\n+    uint256 public feePrecision = 1000;\n+\n+    // FlashMint 事件\n+    event FlashMint(address indexed to, uint256 amount);\n+\n+    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\n+        /// RequireMutation(`_fee < 100` |==> `true`) of: `require(_fee < 100, \"FlashMint: fee too high\");`\n+        require(true, \"FlashMint: fee too high\");\n+        flashMintFee = _fee;\n+    }\n+\n+    function calcPremium(uint256 amount) public view returns (uint256){\n+        return ((amount*flashMintFee)/feePrecision);\n+    }\n+\n+    // FlashMint 函数\n+    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\n+        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\n+        uint256 totalPremium = calcPremium(amount);\n+\n+        uint256 amountPlusPremium = amount + totalPremium;\n+        _mint(receiverAddress, amount);\n+\n+        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\n+\n+        _burn(receiverAddress, amountPlusPremium);\n+\n+        emit FlashMint(receiverAddress, amount);\n+    }\n+}\n+\n+interface IFlashMintReceiver {\n+    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\n+}\n",
    "id": "97",
    "name": "mutants/97/TCB10_FlashMint.sol",
    "original": "TCB10_FlashMint.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,42 +1,43 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-contract TCB10_FlashMint is ERC20, ReentrancyGuard {\r\n-    uint256 private constant MAX_SUPPLY = type(uint256).max;\r\n-    uint256 public flashMintFee;\r\n-    uint256 public feePrecision = 1000;\r\n-\r\n-    // FlashMint 事件\r\n-    event FlashMint(address indexed to, uint256 amount);\r\n-\r\n-    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\r\n-        require(_fee < 100, \"FlashMint: fee too high\");\r\n-        flashMintFee = _fee;\r\n-    }\r\n-\r\n-    function calcPremium(uint256 amount) public view returns (uint256){\r\n-        return ((amount*flashMintFee)/feePrecision);\r\n-    }\r\n-\r\n-    // FlashMint 函数\r\n-    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\r\n-        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\r\n-        uint256 totalPremium = calcPremium(amount);\r\n-\r\n-        uint256 amountPlusPremium = amount + totalPremium;\r\n-        _mint(receiverAddress, amount);\r\n-\r\n-        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\r\n-\r\n-        _burn(receiverAddress, amountPlusPremium);\r\n-\r\n-        emit FlashMint(receiverAddress, amount);\r\n-    }\r\n-}\r\n-\r\n-interface IFlashMintReceiver {\r\n-    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+contract TCB10_FlashMint is ERC20, ReentrancyGuard {\n+    uint256 private constant MAX_SUPPLY = type(uint256).max;\n+    uint256 public flashMintFee;\n+    uint256 public feePrecision = 1000;\n+\n+    // FlashMint 事件\n+    event FlashMint(address indexed to, uint256 amount);\n+\n+    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\n+        /// RequireMutation(`_fee < 100` |==> `false`) of: `require(_fee < 100, \"FlashMint: fee too high\");`\n+        require(false, \"FlashMint: fee too high\");\n+        flashMintFee = _fee;\n+    }\n+\n+    function calcPremium(uint256 amount) public view returns (uint256){\n+        return ((amount*flashMintFee)/feePrecision);\n+    }\n+\n+    // FlashMint 函数\n+    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\n+        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\n+        uint256 totalPremium = calcPremium(amount);\n+\n+        uint256 amountPlusPremium = amount + totalPremium;\n+        _mint(receiverAddress, amount);\n+\n+        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\n+\n+        _burn(receiverAddress, amountPlusPremium);\n+\n+        emit FlashMint(receiverAddress, amount);\n+    }\n+}\n+\n+interface IFlashMintReceiver {\n+    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\n+}\n",
    "id": "98",
    "name": "mutants/98/TCB10_FlashMint.sol",
    "original": "TCB10_FlashMint.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,42 +1,43 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-contract TCB10_FlashMint is ERC20, ReentrancyGuard {\r\n-    uint256 private constant MAX_SUPPLY = type(uint256).max;\r\n-    uint256 public flashMintFee;\r\n-    uint256 public feePrecision = 1000;\r\n-\r\n-    // FlashMint 事件\r\n-    event FlashMint(address indexed to, uint256 amount);\r\n-\r\n-    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\r\n-        require(_fee < 100, \"FlashMint: fee too high\");\r\n-        flashMintFee = _fee;\r\n-    }\r\n-\r\n-    function calcPremium(uint256 amount) public view returns (uint256){\r\n-        return ((amount*flashMintFee)/feePrecision);\r\n-    }\r\n-\r\n-    // FlashMint 函数\r\n-    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\r\n-        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\r\n-        uint256 totalPremium = calcPremium(amount);\r\n-\r\n-        uint256 amountPlusPremium = amount + totalPremium;\r\n-        _mint(receiverAddress, amount);\r\n-\r\n-        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\r\n-\r\n-        _burn(receiverAddress, amountPlusPremium);\r\n-\r\n-        emit FlashMint(receiverAddress, amount);\r\n-    }\r\n-}\r\n-\r\n-interface IFlashMintReceiver {\r\n-    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+contract TCB10_FlashMint is ERC20, ReentrancyGuard {\n+    uint256 private constant MAX_SUPPLY = type(uint256).max;\n+    uint256 public flashMintFee;\n+    uint256 public feePrecision = 1000;\n+\n+    // FlashMint 事件\n+    event FlashMint(address indexed to, uint256 amount);\n+\n+    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\n+        require(_fee < 100, \"FlashMint: fee too high\");\n+        /// AssignmentMutation(`_fee` |==> `0`) of: `flashMintFee = _fee;`\n+        flashMintFee = 0;\n+    }\n+\n+    function calcPremium(uint256 amount) public view returns (uint256){\n+        return ((amount*flashMintFee)/feePrecision);\n+    }\n+\n+    // FlashMint 函数\n+    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\n+        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\n+        uint256 totalPremium = calcPremium(amount);\n+\n+        uint256 amountPlusPremium = amount + totalPremium;\n+        _mint(receiverAddress, amount);\n+\n+        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\n+\n+        _burn(receiverAddress, amountPlusPremium);\n+\n+        emit FlashMint(receiverAddress, amount);\n+    }\n+}\n+\n+interface IFlashMintReceiver {\n+    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\n+}\n",
    "id": "99",
    "name": "mutants/99/TCB10_FlashMint.sol",
    "original": "TCB10_FlashMint.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "AssignmentMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,42 +1,43 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-contract TCB10_FlashMint is ERC20, ReentrancyGuard {\r\n-    uint256 private constant MAX_SUPPLY = type(uint256).max;\r\n-    uint256 public flashMintFee;\r\n-    uint256 public feePrecision = 1000;\r\n-\r\n-    // FlashMint 事件\r\n-    event FlashMint(address indexed to, uint256 amount);\r\n-\r\n-    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\r\n-        require(_fee < 100, \"FlashMint: fee too high\");\r\n-        flashMintFee = _fee;\r\n-    }\r\n-\r\n-    function calcPremium(uint256 amount) public view returns (uint256){\r\n-        return ((amount*flashMintFee)/feePrecision);\r\n-    }\r\n-\r\n-    // FlashMint 函数\r\n-    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\r\n-        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\r\n-        uint256 totalPremium = calcPremium(amount);\r\n-\r\n-        uint256 amountPlusPremium = amount + totalPremium;\r\n-        _mint(receiverAddress, amount);\r\n-\r\n-        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\r\n-\r\n-        _burn(receiverAddress, amountPlusPremium);\r\n-\r\n-        emit FlashMint(receiverAddress, amount);\r\n-    }\r\n-}\r\n-\r\n-interface IFlashMintReceiver {\r\n-    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+contract TCB10_FlashMint is ERC20, ReentrancyGuard {\n+    uint256 private constant MAX_SUPPLY = type(uint256).max;\n+    uint256 public flashMintFee;\n+    uint256 public feePrecision = 1000;\n+\n+    // FlashMint 事件\n+    event FlashMint(address indexed to, uint256 amount);\n+\n+    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\n+        require(_fee < 100, \"FlashMint: fee too high\");\n+        /// AssignmentMutation(`_fee` |==> `1`) of: `flashMintFee = _fee;`\n+        flashMintFee = 1;\n+    }\n+\n+    function calcPremium(uint256 amount) public view returns (uint256){\n+        return ((amount*flashMintFee)/feePrecision);\n+    }\n+\n+    // FlashMint 函数\n+    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\n+        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\n+        uint256 totalPremium = calcPremium(amount);\n+\n+        uint256 amountPlusPremium = amount + totalPremium;\n+        _mint(receiverAddress, amount);\n+\n+        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\n+\n+        _burn(receiverAddress, amountPlusPremium);\n+\n+        emit FlashMint(receiverAddress, amount);\n+    }\n+}\n+\n+interface IFlashMintReceiver {\n+    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\n+}\n",
    "id": "100",
    "name": "mutants/100/TCB10_FlashMint.sol",
    "original": "TCB10_FlashMint.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,42 +1,43 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-contract TCB10_FlashMint is ERC20, ReentrancyGuard {\r\n-    uint256 private constant MAX_SUPPLY = type(uint256).max;\r\n-    uint256 public flashMintFee;\r\n-    uint256 public feePrecision = 1000;\r\n-\r\n-    // FlashMint 事件\r\n-    event FlashMint(address indexed to, uint256 amount);\r\n-\r\n-    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\r\n-        require(_fee < 100, \"FlashMint: fee too high\");\r\n-        flashMintFee = _fee;\r\n-    }\r\n-\r\n-    function calcPremium(uint256 amount) public view returns (uint256){\r\n-        return ((amount*flashMintFee)/feePrecision);\r\n-    }\r\n-\r\n-    // FlashMint 函数\r\n-    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\r\n-        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\r\n-        uint256 totalPremium = calcPremium(amount);\r\n-\r\n-        uint256 amountPlusPremium = amount + totalPremium;\r\n-        _mint(receiverAddress, amount);\r\n-\r\n-        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\r\n-\r\n-        _burn(receiverAddress, amountPlusPremium);\r\n-\r\n-        emit FlashMint(receiverAddress, amount);\r\n-    }\r\n-}\r\n-\r\n-interface IFlashMintReceiver {\r\n-    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+contract TCB10_FlashMint is ERC20, ReentrancyGuard {\n+    uint256 private constant MAX_SUPPLY = type(uint256).max;\n+    uint256 public flashMintFee;\n+    uint256 public feePrecision = 1000;\n+\n+    // FlashMint 事件\n+    event FlashMint(address indexed to, uint256 amount);\n+\n+    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\n+        require(_fee < 100, \"FlashMint: fee too high\");\n+        flashMintFee = _fee;\n+    }\n+\n+    function calcPremium(uint256 amount) public view returns (uint256){\n+        return ((amount*flashMintFee)/feePrecision);\n+    }\n+\n+    // FlashMint 函数\n+    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\n+        /// RequireMutation(`totalSupply() + amount <= MAX_SUPPLY` |==> `true`) of: `require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");`\n+        require(true, \"FlashMint: cap exceeded\");\n+        uint256 totalPremium = calcPremium(amount);\n+\n+        uint256 amountPlusPremium = amount + totalPremium;\n+        _mint(receiverAddress, amount);\n+\n+        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\n+\n+        _burn(receiverAddress, amountPlusPremium);\n+\n+        emit FlashMint(receiverAddress, amount);\n+    }\n+}\n+\n+interface IFlashMintReceiver {\n+    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\n+}\n",
    "id": "101",
    "name": "mutants/101/TCB10_FlashMint.sol",
    "original": "TCB10_FlashMint.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,42 +1,43 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-contract TCB10_FlashMint is ERC20, ReentrancyGuard {\r\n-    uint256 private constant MAX_SUPPLY = type(uint256).max;\r\n-    uint256 public flashMintFee;\r\n-    uint256 public feePrecision = 1000;\r\n-\r\n-    // FlashMint 事件\r\n-    event FlashMint(address indexed to, uint256 amount);\r\n-\r\n-    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\r\n-        require(_fee < 100, \"FlashMint: fee too high\");\r\n-        flashMintFee = _fee;\r\n-    }\r\n-\r\n-    function calcPremium(uint256 amount) public view returns (uint256){\r\n-        return ((amount*flashMintFee)/feePrecision);\r\n-    }\r\n-\r\n-    // FlashMint 函数\r\n-    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\r\n-        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\r\n-        uint256 totalPremium = calcPremium(amount);\r\n-\r\n-        uint256 amountPlusPremium = amount + totalPremium;\r\n-        _mint(receiverAddress, amount);\r\n-\r\n-        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\r\n-\r\n-        _burn(receiverAddress, amountPlusPremium);\r\n-\r\n-        emit FlashMint(receiverAddress, amount);\r\n-    }\r\n-}\r\n-\r\n-interface IFlashMintReceiver {\r\n-    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+contract TCB10_FlashMint is ERC20, ReentrancyGuard {\n+    uint256 private constant MAX_SUPPLY = type(uint256).max;\n+    uint256 public flashMintFee;\n+    uint256 public feePrecision = 1000;\n+\n+    // FlashMint 事件\n+    event FlashMint(address indexed to, uint256 amount);\n+\n+    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\n+        require(_fee < 100, \"FlashMint: fee too high\");\n+        flashMintFee = _fee;\n+    }\n+\n+    function calcPremium(uint256 amount) public view returns (uint256){\n+        return ((amount*flashMintFee)/feePrecision);\n+    }\n+\n+    // FlashMint 函数\n+    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\n+        /// RequireMutation(`totalSupply() + amount <= MAX_SUPPLY` |==> `false`) of: `require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");`\n+        require(false, \"FlashMint: cap exceeded\");\n+        uint256 totalPremium = calcPremium(amount);\n+\n+        uint256 amountPlusPremium = amount + totalPremium;\n+        _mint(receiverAddress, amount);\n+\n+        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\n+\n+        _burn(receiverAddress, amountPlusPremium);\n+\n+        emit FlashMint(receiverAddress, amount);\n+    }\n+}\n+\n+interface IFlashMintReceiver {\n+    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\n+}\n",
    "id": "102",
    "name": "mutants/102/TCB10_FlashMint.sol",
    "original": "TCB10_FlashMint.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,42 +1,43 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-contract TCB10_FlashMint is ERC20, ReentrancyGuard {\r\n-    uint256 private constant MAX_SUPPLY = type(uint256).max;\r\n-    uint256 public flashMintFee;\r\n-    uint256 public feePrecision = 1000;\r\n-\r\n-    // FlashMint 事件\r\n-    event FlashMint(address indexed to, uint256 amount);\r\n-\r\n-    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\r\n-        require(_fee < 100, \"FlashMint: fee too high\");\r\n-        flashMintFee = _fee;\r\n-    }\r\n-\r\n-    function calcPremium(uint256 amount) public view returns (uint256){\r\n-        return ((amount*flashMintFee)/feePrecision);\r\n-    }\r\n-\r\n-    // FlashMint 函数\r\n-    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\r\n-        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\r\n-        uint256 totalPremium = calcPremium(amount);\r\n-\r\n-        uint256 amountPlusPremium = amount + totalPremium;\r\n-        _mint(receiverAddress, amount);\r\n-\r\n-        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\r\n-\r\n-        _burn(receiverAddress, amountPlusPremium);\r\n-\r\n-        emit FlashMint(receiverAddress, amount);\r\n-    }\r\n-}\r\n-\r\n-interface IFlashMintReceiver {\r\n-    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+contract TCB10_FlashMint is ERC20, ReentrancyGuard {\n+    uint256 private constant MAX_SUPPLY = type(uint256).max;\n+    uint256 public flashMintFee;\n+    uint256 public feePrecision = 1000;\n+\n+    // FlashMint 事件\n+    event FlashMint(address indexed to, uint256 amount);\n+\n+    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\n+        require(_fee < 100, \"FlashMint: fee too high\");\n+        flashMintFee = _fee;\n+    }\n+\n+    function calcPremium(uint256 amount) public view returns (uint256){\n+        return ((amount*flashMintFee)/feePrecision);\n+    }\n+\n+    // FlashMint 函数\n+    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\n+        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\n+        uint256 totalPremium = calcPremium(amount);\n+\n+        uint256 amountPlusPremium = amount + totalPremium;\n+        _mint(receiverAddress, amount);\n+\n+        /// RequireMutation(`IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender)` |==> `true`) of: `require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));`\n+        require(true);\n+\n+        _burn(receiverAddress, amountPlusPremium);\n+\n+        emit FlashMint(receiverAddress, amount);\n+    }\n+}\n+\n+interface IFlashMintReceiver {\n+    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\n+}\n",
    "id": "103",
    "name": "mutants/103/TCB10_FlashMint.sol",
    "original": "TCB10_FlashMint.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,42 +1,43 @@\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"../ERC20.sol\";\r\n-import \"../ReentrancyGuard.sol\";\r\n-\r\n-contract TCB10_FlashMint is ERC20, ReentrancyGuard {\r\n-    uint256 private constant MAX_SUPPLY = type(uint256).max;\r\n-    uint256 public flashMintFee;\r\n-    uint256 public feePrecision = 1000;\r\n-\r\n-    // FlashMint 事件\r\n-    event FlashMint(address indexed to, uint256 amount);\r\n-\r\n-    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\r\n-        require(_fee < 100, \"FlashMint: fee too high\");\r\n-        flashMintFee = _fee;\r\n-    }\r\n-\r\n-    function calcPremium(uint256 amount) public view returns (uint256){\r\n-        return ((amount*flashMintFee)/feePrecision);\r\n-    }\r\n-\r\n-    // FlashMint 函数\r\n-    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\r\n-        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\r\n-        uint256 totalPremium = calcPremium(amount);\r\n-\r\n-        uint256 amountPlusPremium = amount + totalPremium;\r\n-        _mint(receiverAddress, amount);\r\n-\r\n-        require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));\r\n-\r\n-        _burn(receiverAddress, amountPlusPremium);\r\n-\r\n-        emit FlashMint(receiverAddress, amount);\r\n-    }\r\n-}\r\n-\r\n-interface IFlashMintReceiver {\r\n-    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\r\n-}\r\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import \"../ERC20.sol\";\n+import \"../ReentrancyGuard.sol\";\n+\n+contract TCB10_FlashMint is ERC20, ReentrancyGuard {\n+    uint256 private constant MAX_SUPPLY = type(uint256).max;\n+    uint256 public flashMintFee;\n+    uint256 public feePrecision = 1000;\n+\n+    // FlashMint 事件\n+    event FlashMint(address indexed to, uint256 amount);\n+\n+    constructor(uint _totalSupply, uint256 _fee) ERC20(_totalSupply)  {\n+        require(_fee < 100, \"FlashMint: fee too high\");\n+        flashMintFee = _fee;\n+    }\n+\n+    function calcPremium(uint256 amount) public view returns (uint256){\n+        return ((amount*flashMintFee)/feePrecision);\n+    }\n+\n+    // FlashMint 函数\n+    function flashMint(address receiverAddress, uint256 amount) public nonReentrant {\n+        require(totalSupply() + amount <= MAX_SUPPLY, \"FlashMint: cap exceeded\");\n+        uint256 totalPremium = calcPremium(amount);\n+\n+        uint256 amountPlusPremium = amount + totalPremium;\n+        _mint(receiverAddress, amount);\n+\n+        /// RequireMutation(`IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender)` |==> `false`) of: `require(IFlashMintReceiver(receiverAddress).executeOperation(amount,totalPremium,msg.sender));`\n+        require(false);\n+\n+        _burn(receiverAddress, amountPlusPremium);\n+\n+        emit FlashMint(receiverAddress, amount);\n+    }\n+}\n+\n+interface IFlashMintReceiver {\n+    function executeOperation(uint256 amount,uint256 premium,address initiator) external returns (bool);\n+}\n",
    "id": "104",
    "name": "mutants/104/TCB10_FlashMint.sol",
    "original": "TCB10_FlashMint.sol",
    "sourceroot": "/mnt/c/Users/Jupiter/Desktop/UG thesis/formal verification/LiquidityPoolExample/contracts/Token"
  }
]